<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>SSSS Lv Sketcher - by Hugo</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- GSAP CDN for advanced animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root {
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            
            /* Dark Theme (Default) */
            --bg-color-dark: #1A1B1E; 
            --panel-bg-dark: #25262B; 
            --canvas-bg-dark: #FFFFFF;
            --text-color-dark: #F0F0F0; 
            --text-secondary-dark: #A0A3BD; 
            --accent-color-dark: #7071E8; /* Primary accent, used for loader ball */
            --accent-hover-dark: #8A8AFF;
            --active-color-dark: #5051D8; 
            --border-color-dark: #36373A; /* Used for loader steps shadow base */
            --loader-step-color-dark: #4A4C50; /* A slightly lighter version for steps */
            --input-bg-dark: #202124; 
            --input-border-dark: #4A4C50;
            --danger-color-dark: #F44336;
            --danger-hover-dark: #E57373;
            --success-color-dark: #4CAF50;
            --success-hover-dark: #66BB6A;
            --shadow-sm-dark: rgba(0, 0, 0, 0.25);
            --shadow-md-dark: rgba(0, 0, 0, 0.35);

            /* Light Theme */
            --bg-color-light: #F8F9FA;
            --panel-bg-light: #FFFFFF;
            --canvas-bg-light: #FFFFFF;
            --text-color-light: #212529;
            --text-secondary-light: #6C757D;
            --accent-color-light: #007AFF; /* Primary accent for light theme */
            --accent-hover-light: #3390FF;
            --active-color-light: #0056CC;
            --border-color-light: #E9ECEF; /* Used for loader steps shadow base */
            --loader-step-color-light: #DEE2E6; /* A slightly lighter version for steps */
            --input-bg-light: #F1F3F5;
            --input-border-light: #DEE2E6;
            --danger-color-light: #DC3545;
            --danger-hover-light: #E4606D;
            --success-color-light: #28A745;
            --success-hover-light: #2EBF4F;
            --shadow-sm-light: rgba(0, 0, 0, 0.06);
            --shadow-md-light: rgba(0, 0, 0, 0.1);

            /* Applied variables */
            --bg-color: var(--bg-color-dark);
            --panel-bg: var(--panel-bg-dark);
            --canvas-bg: var(--canvas-bg-dark);
            --text-color: var(--text-color-dark);
            --text-secondary: var(--text-secondary-dark);
            --accent-color: var(--accent-color-dark);
            --accent-hover: var(--accent-hover-dark);
            --active-color: var(--active-color-dark);
            --border-color: var(--border-color-dark);
            --loader-step-color: var(--loader-step-color-dark);
            --input-bg: var(--input-bg-dark);
            --input-border: var(--input-border-dark);
            --danger-color: var(--danger-color-dark);
            --danger-hover: var(--danger-hover-dark);
            --success-color: var(--success-color-dark);
            --success-hover: var(--success-hover-dark);
            --shadow-sm: var(--shadow-sm-dark);
            --shadow-md: var(--shadow-md-dark);

            --icon-size: 1.25em; 
            --sidebar-width: 300px;
            --sidebar-width-collapsed: 50px;
        }

        body.light-theme {
            --bg-color: var(--bg-color-light);
            --panel-bg: var(--panel-bg-light);
            --text-color: var(--text-color-light);
            --text-secondary: var(--text-secondary-light);
            --accent-color: var(--accent-color-light);
            --accent-hover: var(--accent-hover-light);
            --active-color: var(--active-color-light);
            --border-color: var(--border-color-light);
            --loader-step-color: var(--loader-step-color-light);
            --input-bg: var(--input-bg-light);
            --input-border: var(--input-border-light);
            --danger-color: var(--danger-color-light);
            --danger-hover: var(--danger-hover-light);
            --success-color: var(--success-color-light);
            --success-hover: var(--success-hover-light);
            --shadow-sm: var(--shadow-sm-light);
            --shadow-md: var(--shadow-md-light);
        }

        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; 
            -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none;
            -moz-user-select: none; -ms-user-select: none; user-select: none;
        }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color); display: flex; flex-direction: row;
            color: var(--text-color);
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .sidebar {
             width: var(--sidebar-width); 
             background-color: var(--panel-bg);
             border-right: 1px solid var(--border-color); 
             display: flex; flex-direction: column; height: 100%; 
             box-shadow: 3px 0 12px var(--shadow-md);
             transition: background-color 0.2s ease, border-color 0.2s ease, width 0.3s ease-in-out, padding 0.3s ease-in-out;
             flex-shrink: 0; 
             overflow: hidden; 
             position: relative;
        }
        .sidebar.collapsed {
            width: var(--sidebar-width-collapsed);
        }
        .sidebar.collapsed .sidebar-header h1,
        .sidebar.collapsed .sidebar-header .subtitle-span,
        .sidebar.collapsed .sidebar-content,
        .sidebar.collapsed #status {
            display: none;
        }
        .sidebar.collapsed .sidebar-header {
            padding: 10px 0;
            height: 40px; 
             border-bottom: none;
        }
         .sidebar.collapsed #toggleSidebarBtn {
            margin: 0 auto; 
        }
        .sidebar.collapsed #themeToggleBtn {
             top: 50%; transform: translateY(-50%); right: -200px;
             opacity:0;
        }


        .sidebar-header {
            padding: 14px 18px; text-align: center; 
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; position: relative;
            display: flex; 
            align-items: center;
            justify-content: space-between; 
        }
         #toggleSidebarBtn {
            font-size: 1.5em; padding: 4px 8px; margin-right: 10px;
            background-color: transparent; border: 1px solid var(--border-color);
            color: var(--text-secondary); border-radius: 5px; line-height: 1;
        }
        #toggleSidebarBtn:hover { background-color: var(--input-bg); color: var(--text-color); border-color: var(--accent-color); }

        .sidebar-header .title-block { flex-grow: 1; text-align: center; }
        .sidebar-header h1 { 
            margin: 0; font-size: 1.2em; color: var(--text-color); font-weight: 600; word-break: break-all; 
        }
        .sidebar-header h1 span { font-size: 0.7em; color: var(--text-secondary); font-weight: 400; margin-left: 5px; }
        .sidebar-header .subtitle-span { display: block; font-size: 0.7em; color: var(--text-secondary); margin-top: 2px; }

        #themeToggleBtn {
            position: static; 
            margin-left: 10px; 
            font-size: 1em; padding: 6px 8px;
            background-color: transparent; border: 1px solid var(--border-color);
            color: var(--text-secondary); border-radius: 5px;
             transition: opacity 0.2s, right 0.3s ease-in-out;
        }
        #themeToggleBtn:hover { background-color: var(--input-bg); color: var(--text-color); border-color: var(--accent-color); }

        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 14px; } 
        .sidebar-content::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-track { background: transparent; }
        .sidebar-content::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 3px; }
        .sidebar-content::-webkit-scrollbar-thumb:hover { background-color: var(--text-secondary); }

        .tool-section { margin-bottom: 18px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color); }
        .tool-section:last-child { border-bottom: none; margin-bottom: 0;}
        .tool-section h3 {
            font-size: 0.75em; margin: 0 0 10px 0; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 1px; font-weight: 500; 
            padding-bottom: 5px; border-bottom: 1px solid var(--border-color);
        }
        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(38px, 1fr)); gap: 7px; margin-bottom: 10px; } 
        .actions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 7px; margin-bottom: 10px; }
        .zoom-actions-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 7px; margin-top: 8px; }


        .sidebar button, .layer-actions button, #palette-add-btn, #rotateScreenBtn {
            padding: 8px; border: 1px solid var(--input-border); 
            background-color: var(--input-bg); color: var(--text-secondary);
            cursor: pointer; border-radius: 6px; font-size: var(--icon-size);
            transition: all 0.15s ease-in-out;
            text-align: center; line-height: 1;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 1px 3px var(--shadow-sm); word-break: keep-all; 
        }
         .actions-grid button, .zoom-actions-grid button { font-size: 0.7em; padding: 7px 9px; }
        #palette-add-btn { font-size: 0.75em; padding: 7px 10px; width: 100%; margin-top: 8px; }
        #rotateScreenBtn {
            position: absolute;
            top: 10px;
            left: 10px; 
            z-index: 1000; 
            font-size: 1.2em; 
            padding: 6px 8px;
             background-color: var(--panel-bg); 
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        #rotateScreenBtn:hover {
             background-color: color-mix(in srgb, var(--input-bg) 80%, var(--text-color) 20%); 
            border-color: var(--accent-hover);
            color: var(--text-color);
        }
        
        .sidebar button.active {
            background-color: var(--active-color); border-color: var(--accent-color);
            color: #fff; box-shadow: 0 0 0 2.5px color-mix(in srgb, var(--accent-color) 40%, transparent), 0 2px 5px var(--shadow-md);
            transform: translateY(0px);
        }
        .sidebar button:hover:not(:disabled):not(.active), #palette-add-btn:hover {
            background-color: color-mix(in srgb, var(--input-bg) 80%, var(--text-color) 20%); 
            border-color: var(--accent-hover);
            color: var(--text-color); transform: translateY(-1px); box-shadow: 0 2px 4px var(--shadow-md);
        }
        .sidebar button:disabled { background-color: var(--input-bg); color: var(--text-secondary); opacity: 0.4; cursor: not-allowed; box-shadow: none; }
        
        .tool-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
        .tool-row label { font-size: 0.75em; color: var(--text-secondary); min-width: 70px; flex-shrink: 0;}
        .tool-row input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            border: 1px solid var(--input-border); padding: 0; width: 36px; height: 26px; 
            cursor: pointer; border-radius: 5px; background-color: transparent;
        }
        .tool-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
        .tool-row input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
        .tool-row input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }

        .tool-row input[type="range"] {
            flex-grow: 1; cursor: pointer; accent-color: var(--accent-color);
            height: 5px; background: var(--input-border); border-radius: 2.5px;
            -webkit-appearance: none; appearance: none; border: none; min-width: 60px; 
        }
        .tool-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: var(--accent-color);
            border-radius: 50%; cursor: pointer; border: 2.5px solid var(--panel-bg); box-shadow: 0 1px 3px var(--shadow-sm);
        }
        .tool-row input[type="range"]::-moz-range-thumb {
            width: 13px; height: 13px; background: var(--accent-color);
            border-radius: 50%; cursor: pointer; border: 2.5px solid var(--panel-bg); box-shadow: 0 1px 3px var(--shadow-sm);
        }

        .tool-row input[type="number"], .tool-row select, .layer-controls select {
            width: auto; flex-grow: 1; max-width: 140px; padding: 7px 9px; border-radius: 5px; 
            border: 1px solid var(--input-border); font-size: 0.75em; 
            background-color: var(--input-bg); color: var(--text-color);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .tool-row input[type="number"]:focus, .tool-row select:focus, .layer-controls select:focus {
            border-color: var(--accent-color); box-shadow: 0 0 0 2.5px color-mix(in srgb, var(--accent-color) 30%, transparent); outline:none;
        }
        .layer-controls { display: flex; align-items: center; gap: 6px; margin-top: 5px; }

        .tool-row #lineWidthValue { font-size: 0.75em; min-width: 25px; text-align: right; color: var(--text-secondary);}
        .tool-row input[type="checkbox"] { cursor: pointer; width: 15px; height: 15px; accent-color: var(--accent-color); margin-right: 4px; vertical-align: middle; }
        
        #layer-panel { list-style:none;padding:0;margin:0 0 8px 0;max-height:120px;overflow-y:auto;border:1px solid var(--border-color);border-radius:6px;background-color:color-mix(in srgb, var(--panel-bg) 90%, black);}
        body.light-theme #layer-panel { background-color: color-mix(in srgb, var(--panel-bg) 95%, black); }
        #layer-panel li { background-color:var(--input-bg);padding:8px 10px;border-bottom:1px solid var(--border-color);display:flex;flex-direction:column;gap:6px;cursor:pointer;transition:background-color 0.15s, border-left-color 0.15s;font-size:0.8em;}
        #layer-panel li:first-child { border-top-left-radius: 5px; border-top-right-radius: 5px; }
        #layer-panel li:last-child { border-bottom: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px;}
        .layer-info { display: flex; align-items: center; gap: 6px; width: 100%;}
        #layer-panel li.active-layer { background-color:var(--panel-bg);border-left:3.5px solid var(--accent-color);font-weight:500;box-shadow:inset 2px 0 5px var(--shadow-sm);}
        #layer-panel li:hover:not(.active-layer) { background-color: var(--border-color); }
        #layer-panel li input[type="checkbox"].layer-visible-toggle { cursor:pointer;accent-color:var(--accent-hover);width:15px;height:15px;}
        #layer-panel li input[type="range"].layer-opacity-slider { width:65px;height:6px;cursor:pointer;accent-color:var(--accent-hover);margin:0 4px;background:transparent;border:none;}
        #layer-panel li span.layer-name { flex-grow:1;color:var(--text-color);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-left:4px;}
        #layer-panel li button.delete-layer { background:none;border:none;cursor:pointer;font-size:1.1em;color:var(--danger-color);padding:0 2px;margin-left:auto;transition:color 0.15s ease;}
        #layer-panel li button.delete-layer:hover { color: var(--danger-hover); transform: scale(1.05); }
        .layer-actions { display:flex;justify-content:center;gap:8px;margin-top:12px;}
        .layer-actions button { font-size:1.25em;padding:7px 10px;}

        .templates-container, #palette-container { display:grid;grid-template-columns:repeat(auto-fill,minmax(28px,1fr));gap:5px;padding:5px;border:1px solid var(--input-border);border-radius:5px;background-color:color-mix(in srgb, var(--panel-bg) 85%, black);min-height:32px;margin-top:5px;max-height:70px;overflow-y:auto;}
        .templates-container::-webkit-scrollbar, #palette-container::-webkit-scrollbar { width: 5px; }
        .templates-container::-webkit-scrollbar-thumb, #palette-container::-webkit-scrollbar-thumb { background-color: var(--text-secondary); border-radius: 2.5px;}

        .swatch { width:100%;padding-bottom:100%;border-radius:4px;cursor:pointer;border:1px solid var(--border-color);box-shadow:inset 0 0 2px var(--shadow-sm);transition:transform 0.1s ease,box-shadow 0.1s ease;}
        .swatch:hover { transform:scale(1.08);box-shadow:0 0 5px var(--accent-hover);}

        #canvas-container { 
            flex-grow:1; width: 0; min-width: 0;
            display:flex;justify-content:center;align-items:center;
            padding:15px;box-sizing:border-box;overflow:hidden; 
            background-color:var(--bg-color);transition:background-color 0.3s ease, margin-left 0.3s ease-in-out;
            position: relative; 
        }
        #drawingCanvas { 
            border:1px solid var(--border-color);cursor:crosshair;
            background-color:var(--canvas-bg);
            box-shadow:0 0 25px var(--shadow-md);
            transition:background-color 0.3s ease,border-color 0.3s ease;
            image-rendering:pixelated; 
            display: block; 
            touch-action: none;
        }
        body.light-theme #drawingCanvas { box-shadow:0 0 15px var(--shadow-md-light);}
        #imageLoader { display:none;}
        #status { padding:10px 15px;border-top:1px solid var(--border-color);font-style:italic;color:var(--text-secondary);font-size:0.8em;text-align:left;background-color:var(--panel-bg);flex-shrink:0;transition:background-color 0.3s ease,color 0.3s ease,border-color 0.3s ease;}
        .property-row { display:none;} .property-row.visible { display:flex;}

        /* Intro Overlay */
        #introOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            z-index: 9999;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center; text-align: center;
            opacity: 1; transition: opacity 0.7s ease-out .2s, visibility 0s linear 0s;
            visibility: visible;
        }
        #introOverlay.hidden {
            opacity: 0; visibility: hidden; transition: opacity 0.5s ease-out, visibility 0s linear 0.5s;
            pointer-events: none;
        }
        .intro-content { padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .intro-content .intro-title { 
            font-size: 2.5em; 
            color: var(--accent-color); 
            margin-bottom: 10px; 
            /* GSAP will handle animation */
            opacity: 0; 
        }
        .intro-content .intro-subtitle { 
            font-size: 1.1em; 
            color: var(--text-secondary); 
            margin-bottom: 30px; 
            /* GSAP will handle animation */
            opacity: 0;
        }
        
        #startSketchingBtn {
            padding: 12px 25px; font-size: 1em; font-weight: 500;
            background-color: var(--accent-color); color: white;
            border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 30px; 
             /* GSAP will handle animation */
            opacity: 0;
        }
        #startSketchingBtn:hover { background-color: var(--accent-hover); }

        /* Bouncing Ball Loader CSS */
        .loader {
            position: relative;
            width: 120px;
            height: 90px; /* Initial height for spacing before ball bounces higher */
            margin: 0 auto 20px auto; /* Space below loader */
            /* GSAP will handle opacity */
            opacity: 0; 
        }

        .loader:before { /* The Bouncing Ball */
            content: "";
            position: absolute;
            bottom: 30px; /* Initial bottom position */
            left: 50px;
            height: 30px;
            width: 30px;
            border-radius: 50%;
            background: var(--accent-color); /* Use accent color */
            animation: loading-bounce 0.5s ease-in-out infinite alternate;
        }

        .loader:after { /* The Steps */
            content: "";
            position: absolute;
            right: 0;
            top: 0;
            height: 7px;
            width: 45px;
            border-radius: 4px;
            /* Step colors are defined by --loader-step-color which changes with theme */
            box-shadow: 0 5px 0 var(--loader-step-color), 
                        -35px 50px 0 var(--loader-step-color), 
                        -70px 95px 0 var(--loader-step-color);
            animation: loading-step 1s ease-in-out infinite;
        }

        @keyframes loading-bounce {
            0% {
                transform: scale(1, 0.7);
            }
            40% {
                transform: scale(0.8, 1.2);
            }
            60% {
                transform: scale(1, 1);
            }
            100% {
                /* Bounce significantly higher, adjust as needed relative to .loader height */
                bottom: 120px; 
            }
        }

        @keyframes loading-step {
            0% {
                box-shadow: 0 10px 0 rgba(0, 0, 0, 0), /* Top step invisible */
                            0 10px 0 var(--loader-step-color), /* Middle step for timing */
                            -35px 50px 0 var(--loader-step-color),
                            -70px 90px 0 var(--loader-step-color);
            }
            100% {
                box-shadow: 0 10px 0 var(--loader-step-color),
                            -35px 50px 0 var(--loader-step-color),
                            -70px 90px 0 var(--loader-step-color),
                            -70px 90px 0 rgba(0, 0, 0, 0); /* Bottom step becomes invisible */
            }
        }


        /* Responsive adjustments */
        @media (orientation: portrait) and (max-width: 768px), 
               (orientation: landscape) and (max-height: 520px) { 
            body { flex-direction: column; height: 100vh; }
            .sidebar { width:100%;height:auto;max-height:50vh; border-right:none;border-bottom:1px solid var(--border-color);box-shadow:0 2px 8px var(--shadow-md);}
            .sidebar.collapsed { width: 100%; height: var(--sidebar-width-collapsed); } 
            .sidebar.collapsed .sidebar-header { justify-content: center; } 
             .sidebar.collapsed #toggleSidebarBtn { margin-right: 0; }
            .sidebar-content { padding: 10px; }
            #canvas-container { padding:10px;height:auto;flex-grow:1;min-height:150px;width:100%;box-sizing:border-box; }
            .tool-grid { grid-template-columns:repeat(auto-fill,minmax(40px,1fr));gap:5px;}
            .actions-grid { grid-template-columns:repeat(auto-fill,minmax(85px,1fr));gap:5px;}
            .templates-container, #palette-container { max-height:60px;}
            #layer-panel { max-height: 100px; }
             .intro-content .intro-title { font-size: 2em; }
             .loader { transform: scale(0.8); } /* Slightly smaller loader */
        }
         @media (max-width: 480px) { 
            .sidebar { max-height: 55vh; } 
            .sidebar-header h1 { font-size: 1.1em; }
            .sidebar-header h1 span, .sidebar-header .subtitle-span { font-size: 0.65em;}
            .tool-section h3 { font-size: 0.75em; margin-bottom: 8px;}
            .tool-grid { grid-template-columns:repeat(auto-fill,minmax(36px,1fr));gap:4px;}
            .sidebar button, .layer-actions button, #palette-add-btn, #rotateScreenBtn { font-size: 1.1em; padding: 6px;} 
            #rotateScreenBtn { font-size: 1.2em; padding: 5px 7px; } 
            .actions-grid button { font-size: 0.7em; padding: 6px 8px; }
            .tool-row label { font-size: 0.75em; min-width: 60px;}
            .tool-row input[type="number"], .tool-row select, .layer-controls select { font-size: 0.7em; padding: 6px 8px; }
            #layer-panel { max-height: 90px; }
             .intro-content .intro-title { font-size: 1.8em; }
             .intro-content .intro-subtitle { font-size: 1em; }
             #startSketchingBtn { padding: 10px 20px; font-size: 0.9em;}
             .loader { transform: scale(0.7); } /* Even smaller loader */
         }
    </style>
</head>
<body>
    <div id="introOverlay">
        <div class="intro-content">
            <h1 class="intro-title">SSSS Lv Sketcher</h1>
            <p class="intro-subtitle">Initializing your creative space...</p>
            <!-- Bouncing Ball Loader -->
            <div class="loader"></div>
            <button id="startSketchingBtn">Start Sketching</button>
        </div>
    </div>

    <div class="sidebar">
        <div class="sidebar-header">
            <button id="toggleSidebarBtn" title="Toggle Controls">☰</button>
            <div class="title-block">
                <h1>SSSS Lv Sketcher <span>by Hugo</span></h1>
                <span class="subtitle-span">Enhanced Edition</span>
            </div>
            <button id="themeToggleBtn" title="Toggle Theme">🌙</button>
        </div>
        <div class="sidebar-content">
            <div class="tool-section"><h3>Tools</h3><div class="tool-grid">
                <button id="penTool" class="active" title="Pen (P)">✏️</button>
                <button id="eraserTool" title="Eraser (E)">🧼</button>
                <button id="fillTool" title="Fill Bucket (F)">🪣</button>
                <button id="lineTool" title="Line (L)">📏</button>
                <button id="shapeTool" title="Shape Tool (H)">💠</button> 
                <button id="textTool" title="Text Tool (T)">Aa</button>
                <button id="eyedropperTool" title="Eyedropper (I)">💧</button>
                <button id="sprayTool" title="Spray Paint (S)">💨</button>
                <button id="selectTool" title="Selection Tool (M)">⬚</button> 
                <button id="moveTool" title="Move Tool (V)">✥</button> 
            </div></div>
            <div class="tool-section"><h3>Properties</h3>
                <div class="tool-row" id="colorTypeRow"><label for="colorTypeSelect">Color Type</label><select id="colorTypeSelect"><option value="solid">Solid</option><option value="linear">Linear Gradient</option></select></div>
                <div class="tool-row property-row" id="solidColorPropsRow"><label for="lineColor">Color</label><input type="color" id="lineColor" value="#8A8AFF"></div>
                <div class="tool-row property-row" id="gradientPropsRow1"><label for="gradientStartColor">Start 🎨</label><input type="color" id="gradientStartColor" value="#8A8AFF"></div>
                <div class="tool-row property-row" id="gradientPropsRow2"><label for="gradientEndColor">End 🎨</label><input type="color" id="gradientEndColor" value="#FF8A8A"></div>
                
                <div class="tool-row property-row" id="shapeTypeRow"> <label for="shapeTypeSelect">Shape</label> <select id="shapeTypeSelect"> <option value="rectangle">Rectangle</option> <option value="circle">Circle</option> <option value="ellipse">Ellipse</option> <option value="triangle">Triangle</option> <option value="star">Star</option> <option value="polygon">Polygon</option> <option value="rhombus">Rhombus</option> </select> </div>
                <div class="tool-row"><label for="lineWidth">Width</label><input type="range" id="lineWidth" min="1" max="100" value="5"><span id="lineWidthValue">5</span>px</div>
                <div class="tool-row"><label for="strokeStyle">Stroke Style</label><select id="strokeStyle"><option value="solid">Solid</option><option value="dashed">Dashed</option><option value="dotted">Dotted</option></select></div>
                <div class="tool-row property-row" id="shapeCommonPropsRow"><label for="fillShapeCheckbox" title="Fill Shape?">Fill Shape</label><input type="checkbox" id="fillShapeCheckbox" title="Fill Shape?"></div>
                <div class="tool-row property-row" id="polygonSidesRow"><label for="polygonSides">Sides</label><input type="number" id="polygonSides" min="3" max="20" value="5"></div>
                <div class="tool-row property-row" id="textPropsRow1"><label for="textSize">Text Size</label><input type="number" id="textSize" min="8" max="150" value="24">px</div>
                <div class="tool-row property-row" id="textPropsRow2"><label for="fontFamily">Font</label><select id="fontFamily"><option>Inter</option><option>Arial</option><option>Verdana</option><option>Georgia</option><option>Times New Roman</option><option>Courier New</option></select></div>
                <div class="tool-row property-row" id="textPropsRow3"><label for="textAlign">Align</label><select id="textAlign"><option value="left">Left</option><option value="center">Center</option><option value="right">Right</option></select></div>
                
                <div class="tool-row" id="gridPropsRow1">
                    <label for="showGridCheckbox">Show Grid</label><input type="checkbox" id="showGridCheckbox">
                    <label for="snapToGridCheckbox" style="min-width:auto; margin-left:5px;">Snap</label><input type="checkbox" id="snapToGridCheckbox">
                </div>
                <div class="tool-row property-row" id="gridPropsRow2">
                    <label for="gridSizeInput">Grid Size</label><input type="number" id="gridSizeInput" value="20" min="5" max="200" step="1"> px
                    <label for="gridColorPicker" style="min-width:auto; margin-left:5px;">Color</label><input type="color" id="gridColorPicker" value="#cccccc">
                </div>
            </div>
            <div class="tool-section"><h3>Actions & Effects</h3>
                <div class="tool-grid"> 
                    <button id="undoBtn" title="Undo (Ctrl+Z)">↩️</button> 
                    <button id="uploadImageBtn" title="Upload Image">🖼️</button> 
                    <button id="clearBtn" title="Clear ALL Layers">🗑️</button> 
                    <button id="saveBtn" title="Save Image">💾</button> 
                    <button id="clearSelectionContentBtn" title="Clear Selected Area (Del/Backspace)">✂️</button>
                    <button id="flipHorizontalBtn" title="Flip Layer Horizontally">⇄</button>
                    <button id="flipVerticalBtn" title="Flip Layer Vertically">⇅</button>
                </div>
                <div class="actions-grid"> 
                    <button id="grayscaleBtn" title="Grayscale Layer">Grayscale</button> 
                    <button id="invertBtn" title="Invert Layer Colors">Invert</button> 
                    <button id="symmetryToggleBtn" title="Toggle Symmetry (X)">OFF</button> 
                </div>
                <div class="zoom-actions-grid">
                    <button id="zoomInBtn" title="Zoom In (+)">➕</button>
                    <button id="zoomOutBtn" title="Zoom Out (-)">➖</button>
                    <button id="resetZoomBtn" title="Reset Zoom (0)">⟲</button>
                </div>
                <div class="tool-row" style="margin-top:10px;"><label for="saveFormat">Format</label><select id="saveFormat"><option value="png">PNG</option><option value="jpeg">JPEG</option></select></div>
                <input type="file" id="imageLoader" accept="image/*"/>
            </div>
            <div class="tool-section"><h3>Layers</h3><ul id="layer-panel"></ul><div class="layer-actions"><button id="addLayerBtn" title="Add Layer">➕</button> <button id="mergeLayerBtn" title="Merge Layer Down">Merge ↓</button> <button id="deleteLayerBtn" title="Delete Layer">➖</button></div></div>
            <div class="tool-section"><h3>Color Palette</h3> <div id="palette-container" class="templates-container"></div> <button id="paletteAddBtn" title="Add Current to Palette">➕ Add</button> </div>
            <div class="tool-section"><h3>Solid Templates</h3> <div id="solid-templates-container" class="templates-container"></div> </div>
            <div class="tool-section"><h3>Gradient Templates</h3> <div id="gradient-templates-container" class="templates-container"></div> </div>
        </div>
        <div id="status">Loading SSSS Lv Sketcher...</div>
    </div>
    <div id="canvas-container">
        <canvas id="drawingCanvas"></canvas>
        <button id="rotateScreenBtn" title="Toggle Orientation">🔄</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainCanvas = document.getElementById('drawingCanvas');
            const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
            const colorTypeSelect = document.getElementById('colorTypeSelect');
            const solidColorPropsRow = document.getElementById('solidColorPropsRow');
            const lineColorPicker = document.getElementById('lineColor');
            const gradientPropsRow1 = document.getElementById('gradientPropsRow1');
            const gradientPropsRow2 = document.getElementById('gradientPropsRow2');
            const gradientStartColorPicker = document.getElementById('gradientStartColor');
            const gradientEndColorPicker = document.getElementById('gradientEndColor');
            const shapeTypeRow = document.getElementById('shapeTypeRow'); 
            const shapeTypeSelect = document.getElementById('shapeTypeSelect'); 
            const lineWidthSlider = document.getElementById('lineWidth');
            const lineWidthValue = document.getElementById('lineWidthValue');
            const strokeStyleSelect = document.getElementById('strokeStyle');
            const shapeCommonPropsRow = document.getElementById('shapeCommonPropsRow'); 
            const fillShapeCheckbox = document.getElementById('fillShapeCheckbox');
            const polygonSidesRow = document.getElementById('polygonSidesRow'); 
            const polygonSidesInput = document.getElementById('polygonSides');
            const textPropsRow1 = document.getElementById('textPropsRow1');
            const textPropsRow2 = document.getElementById('textPropsRow2');
            const textPropsRow3 = document.getElementById('textPropsRow3');
            const textSizeInput = document.getElementById('textSize');
            const fontFamilySelect = document.getElementById('fontFamily');
            const textAlignSelect = document.getElementById('textAlign');
            const showGridCheckbox = document.getElementById('showGridCheckbox');
            const snapToGridCheckbox = document.getElementById('snapToGridCheckbox');
            const gridSizeInput = document.getElementById('gridSizeInput');
            const gridColorPicker = document.getElementById('gridColorPicker');
            const undoBtn = document.getElementById('undoBtn');
            const uploadImageBtn = document.getElementById('uploadImageBtn');
            const clearBtn = document.getElementById('clearBtn');
            const saveBtn = document.getElementById('saveBtn');
            const saveFormatSelect = document.getElementById('saveFormat');
            const imageLoader = document.getElementById('imageLoader');
            const grayscaleBtn = document.getElementById('grayscaleBtn');
            const invertBtn = document.getElementById('invertBtn');
            const symmetryToggleBtn = document.getElementById('symmetryToggleBtn');
            const layerPanel = document.getElementById('layer-panel');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const mergeLayerBtn = document.getElementById('mergeLayerBtn');
            const deleteLayerBtn = document.getElementById('deleteLayerBtn');
            const paletteContainer = document.getElementById('palette-container');
            const paletteAddBtn = document.getElementById('paletteAddBtn');
            const solidTemplatesContainer = document.getElementById('solid-templates-container');
            const gradientTemplatesContainer = document.getElementById('gradient-templates-container');
            const statusDiv = document.getElementById('status');
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            const sidebar = document.querySelector('.sidebar');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            const rotateScreenBtn = document.getElementById('rotateScreenBtn');
            const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            
            const introOverlay = document.getElementById('introOverlay');
            const introTitle = introOverlay.querySelector('.intro-title');
            const introSubtitle = introOverlay.querySelector('.intro-subtitle');
            const introLoader = introOverlay.querySelector('.loader');
            const startSketchingBtn = document.getElementById('startSketchingBtn');

            const clearSelectionContentBtn = document.getElementById('clearSelectionContentBtn');
            const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
            const flipVerticalBtn = document.getElementById('flipVerticalBtn');


            // --- State Variables ---
            let currentTool = 'pen';
            let currentShapeType = 'rectangle'; 
            let previousTool = 'pen'; 
            let isDrawing = false; 
            let isSelecting = false; 
            let isMovingSelection = false; 
            let lastX = 0, lastY = 0; 
            let startX = 0, startY = 0; 
            let selectionRect = null; 
            let movingSelectionData = null; 

            let currentColorMode = 'solid'; 
            let currentSolidColor = '#2288ff'; 
            let currentGradient = { start: '#ff0000', end: '#0000ff' };
            let currentWidth = 5; 
            let currentPolygonSides = 5;
            let currentFontSize = 24; 
            let currentFontFamily = 'Arial';
            let currentTextAlign = 'left';
            let currentStrokeStyle = 'solid';
            
            let showGrid = false;
            let snapToGrid = false;
            let gridSize = 20; 
            let gridColor = '#cccccc';
            
            let deviceScale = window.devicePixelRatio || 1; 
            let zoomLevel = 1.0;
            let panX = 0; 
            let panY = 0; 
            let isPanning = false; 
            let lastPanX_mouse, lastPanY_mouse; 
            let pinchStartDistance = 0;
            let lastPinchMidX, lastPinchMidY;

            let symmetryMode = 'OFF'; 
            const symmetryModes = ['OFF', 'Y', 'X', 'XY'];
            let currentSymmetryIndex = 0;
            let paletteColors = [];
            const MAX_PALETTE_COLORS = 24;
            let layers = [];
            let activeLayerIndex = -1;
            let layerCounter = 1;
            let history = {}; 
            let historyStep = {}; 
            const MAX_HISTORY_STEPS = 20;

            const blendModes = [ 'source-over', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity', 'destination-over', 'lighter', 'xor' ];
            const solidColorTemplates = [ "#E74C3C", "#F1C40F", "#2ECC71", "#3498DB", "#9B59B6", "#34495E", "#1ABC9C", "#E67E22", "#BDC3C7", "#7F8C8D", "#F39C12", "#D35400" ];
            const gradientTemplates = [ { name: "Sunset", start: "#FFC371", end: "#FF5F6D" }, { name: "Ocean", start: "#34E89E", end: "#034AD8" }, { name: "Forest", start: "#138808", end: "#228B22" }, { name: "Plum", start: "#4A00E0", end: "#8E2DE2" }, { name: "Rose", start: "#FFDDD2", end: "#FF8DC7" }, { name: "Sky", start: "#0072ff", end: "#00c6ff" }, { name: "Fire", start: "#f12711", end: "#f5af19" }, { name: "Mint", start: "#A1FFCE", end: "#FAFFD1" } ];
            
            let selectionMarchOffset = 0; 

            // --- Initialization & Setup ---
            function animateIntroElements() {
                const tl = gsap.timeline();
                tl.to(introTitle, { opacity: 1, y: 0, scale: 1, duration: 0.8, ease: "power2.out" }, 0.2)
                  .to(introSubtitle, { opacity: 1, y: 0, duration: 0.7, ease: "power1.out" }, "-=0.5")
                  .to(introLoader, { opacity: 1, duration: 0.5, ease: "sine.inOut" }, "-=0.6")
                  .to(startSketchingBtn, { opacity: 1, y: 0, duration: 0.6, ease: "back.out(1.7)" }, "+=0.5"); // Animate button after loader visible
                
                 // Auto-hide intro after animations plus some viewing time
                setTimeout(hideIntro, tl.duration() * 1000 + 2000); // Convert GSAP duration to ms
            }


            function initializeApp() {
                gsap.set(introTitle, { opacity: 0, y: -20, scale: 0.95 });
                gsap.set(introSubtitle, { opacity: 0, y: -15 });
                gsap.set(introLoader, { opacity: 0 });
                gsap.set(startSketchingBtn, { opacity: 0, y: 20 });
                animateIntroElements();
                
                attemptLockOrientation('landscape-primary'); 

                const savedTheme = localStorage.getItem('sketcherTheme');
                if (savedTheme === 'light') { document.body.classList.add('light-theme'); themeToggleBtn.textContent = '🌙'; } else { themeToggleBtn.textContent = '☀️'; }
                
                const sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
                if (sidebarCollapsed) {
                    sidebar.classList.add('collapsed');
                    toggleSidebarBtn.textContent = '☰'; 
                } else {
                    toggleSidebarBtn.textContent = '❮'; 
                }


                lineWidthSlider.value = currentWidth; lineWidthValue.textContent = currentWidth;
                lineColorPicker.value = currentSolidColor; 
                gradientStartColorPicker.value = currentGradient.start; gradientEndColorPicker.value = currentGradient.end;
                polygonSidesInput.value = currentPolygonSides; shapeTypeSelect.value = currentShapeType;
                textSizeInput.value = currentFontSize; fontFamilySelect.value = currentFontFamily; textAlignSelect.value = currentTextAlign;
                strokeStyleSelect.value = currentStrokeStyle; colorTypeSelect.value = currentColorMode;
                showGridCheckbox.checked = showGrid; snapToGridCheckbox.checked = snapToGrid;
                gridSizeInput.value = gridSize; gridColorPicker.value = gridColor;

                loadPalette(); renderSolidColorTemplates(); renderGradientTemplates();
                initializeCanvasAndLayers(); 
                setupEventListeners(); updateColorPropertiesUI(); updateActiveToolPropertiesUI(); updateCursor();
                statusDiv.textContent = "Select a tool to begin.";

                requestAnimationFrame(animateSelectionMarch); 
            }
            
            function hideIntro() {
                if (introOverlay && !introOverlay.classList.contains('hidden')) { // Check if already hidden
                    gsap.to(introOverlay, { 
                        opacity: 0, 
                        duration: 0.5, 
                        ease: "power1.in",
                        onComplete: () => {
                            introOverlay.classList.add('hidden');
                        } 
                    });
                }
            }

            function initializeCanvasAndLayers() {
                const container = document.getElementById('canvas-container'); 
                const cs = getComputedStyle(container);
                const pX=parseFloat(cs.paddingLeft)+parseFloat(cs.paddingRight), pY=parseFloat(cs.paddingTop)+parseFloat(cs.paddingBottom);
                
                let displayWidth = Math.max(100, container.clientWidth - pX);
                let displayHeight = Math.max(100, container.clientHeight - pY);

                if (container.clientWidth === 0 || displayWidth <=0 ) {
                     const sidebarCurrentWidth = sidebar.classList.contains('collapsed') ? parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width-collapsed')) : parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
                     displayWidth = Math.max(300, window.innerWidth - sidebarCurrentWidth - pX - 30); 
                }
                if (container.clientHeight === 0 || displayHeight <=0) {
                    displayHeight = Math.max(300, window.innerHeight - pY - 30); 
                }


                mainCanvas.style.width = displayWidth + 'px';
                mainCanvas.style.height = displayHeight + 'px';
                mainCanvas.width = Math.round(displayWidth * deviceScale); 
                mainCanvas.height = Math.round(displayHeight * deviceScale);
                
                if (layers.length > 0) {
                    layers.forEach(layer => {
                        if (!layer.canvas) { 
                            console.error("Layer found without a canvas during resize:", layer.name);
                            const c = document.createElement('canvas');
                            layer.canvas = c;
                            layer.context = c.getContext('2d');
                        }
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = layer.canvas.width; 
                        tempCanvas.height = layer.canvas.height; 
                        tempCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);

                        layer.canvas.width = mainCanvas.width; 
                        layer.canvas.height = mainCanvas.height; 
                        layer.context.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0,0, layer.canvas.width, layer.canvas.height);
                    });
                } else {
                    layers=[]; history={}; historyStep={}; layerCounter=1; activeLayerIndex=-1; 
                    addLayer(); 
                }
                renderComposite();
            }

            function setupEventListeners() {
                startSketchingBtn.addEventListener('click', hideIntro);
                toggleSidebarBtn.addEventListener('click', () => {
                    sidebar.classList.toggle('collapsed');
                    const isCollapsed = sidebar.classList.contains('collapsed');
                    toggleSidebarBtn.textContent = isCollapsed ? '☰' : '❮';
                    try {
                        localStorage.setItem('sidebarCollapsed', isCollapsed);
                    } catch (e) { console.warn("Could not save sidebar state:", e); }
                    setTimeout(handleResize, 310); 
                });

                sidebar.addEventListener('click', handleToolbarClick);
                colorTypeSelect.addEventListener('change', handlePropertyChange);
                lineColorPicker.addEventListener('input', handlePropertyChange);
                gradientStartColorPicker.addEventListener('input', handlePropertyChange);
                gradientEndColorPicker.addEventListener('input', handlePropertyChange);
                shapeTypeSelect.addEventListener('change', handlePropertyChange); 
                lineWidthSlider.addEventListener('input', handlePropertyChange);
                strokeStyleSelect.addEventListener('input', handlePropertyChange);
                fillShapeCheckbox.addEventListener('change', handlePropertyChange);
                polygonSidesInput.addEventListener('input', handlePropertyChange);
                textSizeInput.addEventListener('input', handlePropertyChange);
                fontFamilySelect.addEventListener('change', handlePropertyChange);
                textAlignSelect.addEventListener('change', handlePropertyChange);
                showGridCheckbox.addEventListener('change', handlePropertyChange);
                snapToGridCheckbox.addEventListener('change', handlePropertyChange);
                gridSizeInput.addEventListener('input', handlePropertyChange);
                gridColorPicker.addEventListener('input', handlePropertyChange);

                mainCanvas.addEventListener('mousedown',startAction); 
                mainCanvas.addEventListener('mousemove',performAction);
                mainCanvas.addEventListener('mouseup',endAction); 
                mainCanvas.addEventListener('mouseleave',endAction); 
                mainCanvas.addEventListener('wheel', handleWheelZoom, { passive: false }); 

                mainCanvas.addEventListener('touchstart',handleTouchStart,{passive:false}); 
                mainCanvas.addEventListener('touchmove',handleTouchMove,{passive:false});
                mainCanvas.addEventListener('touchend',handleTouchEnd,{passive:false}); 
                mainCanvas.addEventListener('touchcancel',endAction,{passive:false}); 

                imageLoader.addEventListener('change',handleImageUpload); 
                window.addEventListener('resize',handleResize);
                
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', () => {
                        console.log('Screen orientation changed to: ' + screen.orientation.type);
                        handleResize(); 
                    });
                }

                document.addEventListener('keydown',handleKeyboardShortcuts); 
                document.addEventListener('keyup', handleKeyUp); 
                themeToggleBtn.addEventListener('click',toggleTheme);
                grayscaleBtn.addEventListener('click',applyGrayscaleEffect); 
                invertBtn.addEventListener('click',applyInvertEffect);
                symmetryToggleBtn.addEventListener('click',cycleSymmetryMode); 
                paletteAddBtn.addEventListener('click',addCurrentColorToPalette);
                mergeLayerBtn.addEventListener('click', mergeActiveLayerDown);
                zoomInBtn.addEventListener('click', () => zoom(1.25));
                zoomOutBtn.addEventListener('click', () => zoom(0.8));
                resetZoomBtn.addEventListener('click', resetView);
                rotateScreenBtn.addEventListener('click', toggleOrientationLock);
                clearSelectionContentBtn.addEventListener('click', clearSelectedArea);
                flipHorizontalBtn.addEventListener('click', () => flipLayer(true, false));
                flipVerticalBtn.addEventListener('click', () => flipLayer(false, true));
            }
            
            function attemptLockOrientation(orientation = 'landscape-primary') {
                try {
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock(orientation)
                            .then(() => {
                                console.log(`Orientation locked to ${orientation}.`);
                                statusDiv.textContent = `Orientation: ${screen.orientation.type.split('-')[0]}.`;
                                setTimeout(handleResize, 50); 
                            })
                            .catch((error) => {
                                console.warn(`Could not lock orientation to ${orientation}:`, error);
                                statusDiv.textContent = `Orientation lock failed. ${error.message}`;
                            });
                    } else {
                        console.warn('Screen Orientation API not fully supported for locking.');
                        statusDiv.textContent = 'Orientation lock not fully supported.';
                    }
                } catch (e) {
                    console.error("Error attempting to lock orientation:", e);
                    statusDiv.textContent = 'Error trying to lock orientation.';
                }
            }
            
            function toggleOrientationLock() {
                if (!screen.orientation || !screen.orientation.lock) {
                    statusDiv.textContent = "Screen Orientation API not supported for locking.";
                    alert("Automatic screen rotation control is not supported by your browser. Please rotate your device manually.");
                    return;
                }
                const currentOrientationType = screen.orientation.type;
                let targetOrientation = currentOrientationType.startsWith('landscape') ? 'portrait-primary' : 'landscape-primary';
                statusDiv.textContent = `Attempting to switch to ${targetOrientation.split('-')[0]}...`;
                attemptLockOrientation(targetOrientation);
            }

            function updateColorPropertiesUI() {
                solidColorPropsRow.classList.toggle('visible', currentColorMode === 'solid');
                gradientPropsRow1.classList.toggle('visible', currentColorMode === 'linear');
                gradientPropsRow2.classList.toggle('visible', currentColorMode === 'linear');
                document.getElementById('gridPropsRow2').classList.toggle('visible', showGrid); 
                updateCursor();
            }
            function updateActiveToolPropertiesUI() {
                const allPropRows = sidebar.querySelectorAll('.property-row[id$="PropsRow"], .property-row[id$="Row1"], .property-row[id$="Row2"], .property-row[id$="Row3"]');
                allPropRows.forEach(row => row.classList.remove('visible'));

                if (currentTool === 'shape') {
                    shapeTypeRow.classList.add('visible');
                    shapeCommonPropsRow.classList.add('visible');
                    if (currentShapeType === 'polygon') polygonSidesRow.classList.add('visible');
                } else if (currentTool === 'text') {
                    textPropsRow1.classList.add('visible');
                    textPropsRow2.classList.add('visible');
                    textPropsRow3.classList.add('visible');
                }
                const showColorControls = !['select', 'move', 'eyedropper', 'fill'].includes(currentTool);
                colorTypeRow.style.display = showColorControls ? 'flex' : 'none';
                solidColorPropsRow.classList.toggle('visible', currentColorMode === 'solid' && showColorControls);
                gradientPropsRow1.classList.toggle('visible', currentColorMode === 'linear' && showColorControls);
                gradientPropsRow2.classList.toggle('visible', currentColorMode === 'linear' && showColorControls);

                document.getElementById('lineWidth').parentElement.style.display = ['pen', 'eraser', 'line', 'shape', 'spray'].includes(currentTool) ? 'flex' : 'none';
                document.getElementById('strokeStyle').parentElement.style.display = ['pen', 'line', 'shape'].includes(currentTool) ? 'flex' : 'none';
                 
                updateColorPropertiesUI(); 
            }

            function toggleTheme() { document.body.classList.toggle('light-theme'); const isLight=document.body.classList.contains('light-theme'); themeToggleBtn.textContent=isLight?'🌙':'☀️'; try { localStorage.setItem('sketcherTheme',isLight?'light':'dark'); } catch(e) {console.warn("Could not save theme:", e);} statusDiv.textContent=`${isLight?'Light':'Dark'} Theme.`; renderComposite(); }
            function cycleSymmetryMode() { currentSymmetryIndex=(currentSymmetryIndex+1)%symmetryModes.length; symmetryMode=symmetryModes[currentSymmetryIndex]; symmetryToggleBtn.textContent=`${symmetryMode!=='OFF'?symmetryMode+'-':''}Mirror: ${symmetryMode!=='OFF'?'ON':'OFF'}`; symmetryToggleBtn.classList.toggle('active',symmetryMode!=='OFF'); statusDiv.textContent=`${symmetryMode}-Axis Mirror ${symmetryMode!=='OFF'?'Enabled':'Disabled'}.`; }

            function handleToolbarClick(e) {
                const button=e.target.closest('button'); if(!button||button.disabled)return;
                const toolButtons=sidebar.querySelectorAll('.tool-grid button[id$="Tool"]');
                if(Array.from(toolButtons).includes(button)){ 
                    if(!button.classList.contains('active')){ 
                        toolButtons.forEach(btn=>btn.classList.remove('active'));
                        button.classList.add('active'); 
                        previousTool = (currentTool==='eyedropper' || currentTool === 'move' || currentTool === 'select') ? previousTool : currentTool; 
                        currentTool=button.id.replace('Tool',''); 
                        updateActiveToolPropertiesUI();
                        updateCursor(); 
                        statusDiv.textContent=`${currentTool.charAt(0).toUpperCase()+currentTool.slice(1)} selected.`;
                        if (currentTool !== 'select' && currentTool !== 'move') deselect(); 
                    }
                }
                else{switch(button.id){ case 'clearBtn':clearCanvas();break;case 'saveBtn':saveCanvas();break;case 'undoBtn':undoLast();break;case 'uploadImageBtn':imageLoader.click();break;case 'addLayerBtn':addLayer();break;case 'deleteLayerBtn':deleteLayer();break;}}
            }
            function handlePropertyChange(e) {
                const target=e.target; 
                switch(target.id){
                    case 'colorTypeSelect':currentColorMode=target.value; updateColorPropertiesUI(); break;
                    case 'lineColor':currentSolidColor=target.value;break;
                    case 'gradientStartColor':currentGradient.start=target.value;updateCursor();break;
                    case 'gradientEndColor':currentGradient.end=target.value;updateCursor();break;
                    case 'shapeTypeSelect': currentShapeType = target.value; updateActiveToolPropertiesUI(); break; 
                    case 'lineWidth':currentWidth=parseInt(target.value,10);lineWidthValue.textContent=currentWidth;updateCursor();break;
                    case 'strokeStyle':currentStrokeStyle=target.value;break;
                    case 'fillShapeCheckbox': break;
                    case 'polygonSides':currentPolygonSides=Math.max(3,Math.min(20,parseInt(target.value,10)||5)); target.value=currentPolygonSides; break;
                    case 'textSize':currentFontSize=parseInt(target.value,10);break;
                    case 'fontFamily':currentFontFamily=target.value;break;
                    case 'textAlign':currentTextAlign=target.value;break;
                    case 'showGridCheckbox': showGrid = target.checked; updateColorPropertiesUI(); renderComposite(); break;
                    case 'snapToGridCheckbox': snapToGrid = target.checked; break;
                    case 'gridSizeInput': gridSize = Math.max(5, parseInt(target.value, 10) || 20); target.value = gridSize; if(showGrid) renderComposite(); break;
                    case 'gridColorPicker': gridColor = target.value; if(showGrid) renderComposite(); break;
                }
            }
             function handleKeyUp(e) { 
                 if (e.key === ' ') { 
                     isPanning = false; 
                     if (!isMovingSelection && !(currentTool === 'move' && selectionRect)) {
                        updateCursor();
                     }
                } 
            }
            function handleKeyboardShortcuts(e) { 
                if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){e.preventDefault();undoLast();} 
                if(document.activeElement.tagName==='INPUT'||document.activeElement.tagName==='SELECT')return; 
                
                const toolMap={p:'penTool',e:'eraserTool',l:'lineTool',h:'shapeTool',f:'fillTool',t:'textTool',i:'eyedropperTool',s:'sprayTool', m:'selectTool', v:'moveTool'}; 
                if(toolMap[e.key.toLowerCase()]){
                    e.preventDefault();
                    document.getElementById(toolMap[e.key.toLowerCase()])?.click();
                }
                if(e.key.toLowerCase()==='x' && (e.ctrlKey||e.metaKey)) symmetryToggleBtn.click(); 
                if (e.key === 'Escape') { if (selectionRect) { deselect(); statusDiv.textContent = "Selection cleared."; e.preventDefault(); } }
                if (e.key === 'Delete' || e.key === 'Backspace') { if (selectionRect) { clearSelectedArea(); e.preventDefault(); } }


                if (e.key === ' ' && !isDrawing && !isSelecting && !isMovingSelection) { 
                    e.preventDefault(); 
                    if (!isPanning) { 
                        isPanning = true; 
                        lastPanX_mouse = undefined; lastPanY_mouse = undefined; 
                        mainCanvas.style.cursor = 'grab';
                    } 
                } 
                if (e.key === '+' || e.key === '=') { e.preventDefault(); zoom(1.1); }
                if (e.key === '-' || e.key === '_') { e.preventDefault(); zoom(0.9); }
                if (e.key === '0') { e.preventDefault(); resetView(); }
            }

            function addLayer(){const c=document.createElement('canvas');c.width=mainCanvas.width;c.height=mainCanvas.height; const ctx=c.getContext('2d');if(!ctx)return;const l={id:`layer-${layerCounter}`,canvas:c,context:ctx,name:`Layer ${layerCounter++}`,visible:true,opacity:1.0,blendMode:'source-over'};layers.push(l);const i=layers.length-1;history[i]=[];historyStep[i]=-1;setActiveLayer(i);renderLayerPanel();saveHistory();renderComposite();statusDiv.textContent=`Added ${l.name}.`;}
            function deleteLayer(){if(layers.length<=1){alert("Cannot delete last layer.");return;}if(activeLayerIndex<0||activeLayerIndex>=layers.length)return;const n=layers[activeLayerIndex].name;if(!confirm(`Delete "${n}"?`))return;const d=activeLayerIndex;layers.splice(d,1);const oH=history,oHS=historyStep;history={};historyStep={};for(let i=0;i<layers.length;i++){const oi=(i<d)?i:i+1;history[i]=oH[oi]||[];historyStep[i]=oHS[oi]===undefined?-1:oHS[oi];}setActiveLayer(Math.max(0,d-1));renderLayerPanel();renderComposite();statusDiv.textContent=`Deleted ${n}.`;}
            function mergeActiveLayerDown(){if(activeLayerIndex<=0||activeLayerIndex>=layers.length){statusDiv.textContent="Cannot merge.";updateMergeButtonState();return;}const srcL=layers[activeLayerIndex],tgtL=layers[activeLayerIndex-1];if(!confirm(`Merge "${srcL.name}" down onto "${tgtL.name}"?`))return;saveHistory(activeLayerIndex-1);const tgtCtx=tgtL.context;tgtCtx.globalAlpha=srcL.opacity;tgtCtx.globalCompositeOperation=srcL.blendMode;tgtCtx.drawImage(srcL.canvas,0,0);tgtCtx.globalAlpha=1.0;tgtCtx.globalCompositeOperation='source-over';saveHistory(activeLayerIndex-1);layers.splice(activeLayerIndex,1);const oH=history,oHS=historyStep;history={};historyStep={};for(let i=0;i<layers.length;i++){const oIdx=(i<activeLayerIndex)?i:i+1;history[i]=oH[oIdx]||[];historyStep[i]=oHS[oIdx]===undefined?-1:oHS[oIdx];}setActiveLayer(activeLayerIndex-1);renderLayerPanel();renderComposite();statusDiv.textContent=`Merged "${srcL.name}" down.`;}
            function updateMergeButtonState(){mergeLayerBtn.disabled=!(activeLayerIndex>0&&activeLayerIndex<layers.length);}
            function setActiveLayer(i){if(i>=0&&i<layers.length){activeLayerIndex=i;renderLayerPanel();updateUndoButtonState();updateMergeButtonState();if(layers[i])statusDiv.textContent=`Active: ${layers[i].name}.`;}else{activeLayerIndex=-1;updateMergeButtonState();}}
            function getActiveLayer(){return(activeLayerIndex>=0&&activeLayerIndex<layers.length)?layers[activeLayerIndex]:null;}
            function getActiveContext(){const l=getActiveLayer();return l?l.context:null;}
            function renderLayerPanel(){if(!layerPanel)return;layerPanel.innerHTML='';layers.forEach((l,idx)=>{const li=document.createElement('li');li.dataset.index=idx;li.classList.toggle('active-layer',idx===activeLayerIndex);const idiv=document.createElement('div');idiv.className='layer-info';idiv.onclick=(e)=>{if(e.target===idiv||e.target.classList.contains('layer-name')||(e.target.tagName==='INPUT'&&e.target.type==='checkbox'))setActiveLayer(idx);};const vc=document.createElement('input');vc.type='checkbox';vc.checked=l.visible;vc.title="Visibility";vc.className='layer-visible-toggle';vc.onchange=(e)=>{l.visible=e.target.checked;renderComposite();};const ns=document.createElement('span');ns.className='layer-name';ns.textContent=l.name;ns.ondblclick=()=>{const n=prompt(`Rename "${l.name}":`,l.name);if(n&&n.trim()){l.name=n.trim();renderLayerPanel();statusDiv.textContent=`Renamed to "${l.name}".`;}};const os=document.createElement('input');os.type='range';os.min=0;os.max=1;os.step=0.05;os.value=l.opacity;os.title=`Opacity: ${Math.round(l.opacity*100)}%`;os.className='layer-opacity-slider';os.oninput=(e)=>{l.opacity=parseFloat(e.target.value);os.title=`Opacity: ${Math.round(l.opacity*100)}%`;renderComposite();};const db=document.createElement('button');db.className='delete-layer';db.innerHTML='🗑️';db.title="Delete";db.onclick=(e)=>{e.stopPropagation();setActiveLayer(idx);deleteLayer();};idiv.appendChild(vc);idiv.appendChild(ns);idiv.appendChild(os);idiv.appendChild(db);li.appendChild(idiv);const cdiv=document.createElement('div');cdiv.className='layer-controls';const bl=document.createElement('label');bl.textContent='Blend:';bl.style.fontSize='0.8em';const bs=document.createElement('select');bs.title="Blend Mode";blendModes.forEach(m=>{const o=document.createElement('option');o.value=m;o.textContent=m.charAt(0).toUpperCase()+m.slice(1);if(m===l.blendMode)o.selected=true;bs.appendChild(o);});bs.onchange=(e)=>{l.blendMode=e.target.value;renderComposite();statusDiv.textContent=`${l.name} blend: ${l.blendMode}.`;};cdiv.appendChild(bl);cdiv.appendChild(bs);li.appendChild(cdiv);layerPanel.appendChild(li);});deleteLayerBtn.disabled=layers.length<=1; updateMergeButtonState();}

            function deselect() {
                selectionRect = null;
                movingSelectionData = null; 
                renderComposite(); 
                updateCursor();
            }

            function drawSelectionOutline(ctx) { 
                if (!selectionRect) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 1 / (zoomLevel * deviceScale); 
                ctx.setLineDash([4 / (zoomLevel*deviceScale), 4 / (zoomLevel*deviceScale)]);
                ctx.lineDashOffset = -selectionMarchOffset / (zoomLevel*deviceScale);
                ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineDashOffset = (4 - selectionMarchOffset) / (zoomLevel*deviceScale);
                ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
                ctx.restore();
            }
            
            function animateSelectionMarch() {
                selectionMarchOffset = (selectionMarchOffset + 0.5) % 8; 
                if (selectionRect) {
                    renderComposite(); 
                }
                requestAnimationFrame(animateSelectionMarch);
            }

            function getSelectionClipPath(targetCtx, forDrawingOnLayer = false) {
                if (!selectionRect) return null;

                const path = new Path2D();
                let x, y, w, h;

                if (forDrawingOnLayer) { 
                    x = selectionRect.x * deviceScale;
                    y = selectionRect.y * deviceScale;
                    w = selectionRect.width * deviceScale;
                    h = selectionRect.height * deviceScale;
                } else { 
                    x = selectionRect.x;
                    y = selectionRect.y;
                    w = selectionRect.width;
                    h = selectionRect.height;
                }
                if (w < 0) { x += w; w = -w; }
                if (h < 0) { y += h; h = -h; }

                path.rect(x, y, w, h);
                return path;
            }

            function clearSelectedArea() {
                if (!selectionRect) {
                    statusDiv.textContent = "No selection to clear.";
                    return;
                }
                const layerCtx = getActiveContext();
                if (!layerCtx) return;
                saveHistory();

                const clipPath = getSelectionClipPath(layerCtx, true); 
                layerCtx.save();
                layerCtx.clip(clipPath);
                layerCtx.clearRect(0, 0, layerCtx.canvas.width, layerCtx.canvas.height); 
                layerCtx.restore();
                
                saveHistory();
                renderComposite();
                statusDiv.textContent = "Selected area cleared.";
            }

            function inverseViewTransform(displayX, displayY) { 
                return {
                    x: (displayX - panX) / zoomLevel, 
                    y: (displayY - panY) / zoomLevel  
                };
            }

            function drawGrid(ctx) { 
                if(!showGrid||!ctx)return;
                const {x: tlx_world, y: tly_world} = inverseViewTransform(0, 0); 
                const {x: brx_world, y: bry_world} = inverseViewTransform(mainCanvas.clientWidth, mainCanvas.clientHeight); 

                ctx.save();
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1 / (zoomLevel * deviceScale); 
                ctx.globalAlpha = 0.3;
                ctx.setLineDash([]);

                const startGridX = Math.floor(tlx_world / gridSize) * gridSize;
                const endGridX = Math.ceil(brx_world / gridSize) * gridSize;
                const startGridY = Math.floor(tly_world / gridSize) * gridSize;
                const endGridY = Math.ceil(bry_world / gridSize) * gridSize;
                
                for(let x = startGridX; x <= endGridX; x += gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, tly_world); ctx.lineTo(x, bry_world); ctx.stroke();
                }
                for(let y = startGridY; y <= endGridY; y += gridSize) {
                    ctx.beginPath(); ctx.moveTo(tlx_world, y); ctx.lineTo(brx_world, y); ctx.stroke();
                }
                ctx.restore(); 
            }
            function renderComposite(){
                if(!mainCtx)return; 
                const bg=getComputedStyle(document.body).getPropertyValue('--canvas-bg').trim();
                mainCtx.fillStyle=bg;
                mainCtx.fillRect(0,0,mainCanvas.width,mainCanvas.height); 
                
                mainCtx.save();
                mainCtx.translate(panX * deviceScale, panY * deviceScale); 
                mainCtx.scale(zoomLevel * deviceScale, zoomLevel * deviceScale); 
                drawGrid(mainCtx); 
                mainCtx.restore(); 

                layers.forEach(l=>{
                    if(l.visible&&l.canvas){
                        mainCtx.save();
                        mainCtx.globalAlpha=l.opacity;
                        mainCtx.globalCompositeOperation=l.blendMode||'source-over';
                        
                        mainCtx.translate(panX * deviceScale, panY * deviceScale);
                        mainCtx.scale(zoomLevel * deviceScale, zoomLevel * deviceScale);
                        
                        mainCtx.drawImage(
                            l.canvas, 
                            0, 0, l.canvas.width, l.canvas.height, 
                            0, 0, l.canvas.width / deviceScale, l.canvas.height / deviceScale
                        );
                        mainCtx.restore();
                    }
                });

                mainCtx.save();
                mainCtx.translate(panX * deviceScale, panY * deviceScale);
                mainCtx.scale(zoomLevel * deviceScale, zoomLevel * deviceScale);
                drawSelectionOutline(mainCtx);
                mainCtx.restore();

                if (currentTool === 'move' && isMovingSelection && movingSelectionData && movingSelectionData.imageData) {
                    mainCtx.save();
                    mainCtx.translate(panX * deviceScale, panY * deviceScale);
                    mainCtx.scale(zoomLevel * deviceScale, zoomLevel * deviceScale);
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = movingSelectionData.imageData.width;
                    tempCanvas.height = movingSelectionData.imageData.height;
                    tempCanvas.getContext('2d').putImageData(movingSelectionData.imageData, 0, 0);

                    mainCtx.globalAlpha = 0.8; 
                    mainCtx.drawImage(tempCanvas, movingSelectionData.x, movingSelectionData.y, movingSelectionData.imageData.width / deviceScale, movingSelectionData.imageData.height / deviceScale);
                    mainCtx.restore();
                }
            }
            
            function updateCursor(){
                if(!getActiveLayer()){mainCanvas.style.cursor='not-allowed';return;} 
                if(isPanning) {mainCanvas.style.cursor = 'grabbing'; return;} 
                if(currentTool === 'move' && selectionRect && isDrawing) { 
                    mainCanvas.style.cursor = 'grabbing'; return;
                }
                if(currentTool === 'move' && selectionRect) {
                    mainCanvas.style.cursor = 'grab'; return;
                }

                const s=Math.max(2,currentWidth);
                switch(currentTool){
                    case 'eraser':const sc=(currentSolidColor==='#ffffff'||currentSolidColor==='rgb(255,255,255)')?'black':'white';mainCanvas.style.cursor=`url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${s*2+2}" height="${s*2+2}" viewport="0 0 ${s*2+2} ${s*2+2}"><circle cx="${s+1}" cy="${s+1}" r="${s}" fill="rgba(255,255,255,0.3)" stroke="${sc}" stroke-width="1.5"/></svg>') ${s+1} ${s+1}, crosshair`;break;
                    case 'fill':mainCanvas.style.cursor=`url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="${encodeURIComponent(currentColorMode==='solid'?currentSolidColor:currentGradient.start)}" viewBox="0 0 16 16"><path d="M2.822 2.06C2.222 2.06 2 2.222 2 2.822v10.356c0 .6.222.822.822.822h10.356c.6 0 .822-.222.822-.822V2.822c0-.6-.222-.822-.822-.822H2.822zm-.06 1.55H13.24v7.978H2.762V3.61zm1.22 1.168L2.762 6.33V4.778h1.22zm0 2.94L2.762 9.27V7.718h1.22zm0 2.94L2.762 12.2V10.658h1.22zM13.24 6.33l-1.22-1.552V6.33h1.22zm0 2.94l-1.22-1.552V9.27h1.22zm0 2.94l-1.22-1.552V12.2h1.22zM4.542 4.778h7.016v1.55H4.542V4.778zm0 2.94h7.016v1.55H4.542V7.718zm0 2.94h7.016v1.55H4.542v10.658zM12.02 4.778L10.8 6.33h1.22V4.778zm-1.22 2.94L9.58 9.27h1.22V7.718zm-1.22 2.94L8.36 12.2h1.22v-1.552z"/></svg>') 4 20, pointer`;break;
                    case 'text':mainCanvas.style.cursor='text';break;
                    case 'eyedropper':mainCanvas.style.cursor=`url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path><path d="M12 12.58V21.5"></path><path d="M8.27 8.27L4 12.54"></path></svg>') 0 24, crosshair`;break;
                    case 'spray':mainCanvas.style.cursor=`url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="${encodeURIComponent(currentColorMode==='solid'?currentSolidColor:currentGradient.start)}" stroke-width="1.5"><circle cx="12" cy="12" r="3"/><path d="M12 5 V 2 M12 22 V 19 M19 12 H 22 M2 12 H 5 M17.65 6.35 L 19.07 4.93 M4.93 19.07 L 6.35 17.65 M17.65 17.65 L 19.07 19.07 M4.93 4.93 L 6.35 6.35"/></svg>') 12 12, crosshair`;break;
                    case 'select': mainCanvas.style.cursor = 'crosshair'; break;
                    case 'move': mainCanvas.style.cursor = (selectionRect ? 'grab' : 'default'); break; 
                    default:mainCanvas.style.cursor='crosshair';break;
                }
            }

            function getEventPos(e, canvas = mainCanvas) { const r=canvas.getBoundingClientRect();let x,y;if(e.touches&&e.touches.length>0){x=e.touches[0].clientX-r.left;y=e.touches[0].clientY-r.top;}else{x=e.clientX-r.left;y=e.clientY-r.top;} return {x,y};} 
            function snapCoord(coord, currentGridSize) { return snapToGrid ? Math.round(coord / currentGridSize) * currentGridSize : coord; }
            
            function handleTouchStart(e){ e.preventDefault(); if (e.touches.length === 1 && !isPanning) { startAction(e.touches[0]); } else if (e.touches.length === 2) { isDrawing = false; isSelecting = false; isMovingSelection = false; isPanning = true; pinchStartDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); lastPinchMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2; lastPinchMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2; } } 
            function handleTouchMove(e){ e.preventDefault(); if (e.touches.length === 1 && !isPanning) { performAction(e.touches[0]); } else if (e.touches.length === 2 && isPanning) { const currentPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2; const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2; const scaleAmount = currentPinchDistance / pinchStartDistance; zoom(scaleAmount, midX - mainCanvas.getBoundingClientRect().left, midY - mainCanvas.getBoundingClientRect().top); panX += (midX - lastPinchMidX); panY += (midY - lastPinchMidY); pinchStartDistance = currentPinchDistance; lastPinchMidX = midX; lastPinchMidY = midY; renderComposite(); } }
            function handleTouchEnd(e){ e.preventDefault(); if (e.touches.length < 2 && isPanning) { isPanning = false; updateCursor(); } if (!isPanning && (isDrawing || isSelecting || isMovingSelection) && e.changedTouches.length > 0) { endAction(e.changedTouches[0]); } else if (!isPanning && !isDrawing && !isSelecting && !isMovingSelection && e.changedTouches.length > 0) { if (currentTool === 'eyedropper' || currentTool === 'fill') { startAction(e.changedTouches[0]); endAction(e.changedTouches[0]); } } } 
            function handleWheelZoom(e) { e.preventDefault(); const {x, y} = getEventPos(e); const delta = e.deltaY > 0 ? 0.9 : 1.1; zoom(delta, x, y); }
            
            function zoom(factor, centerX, centerY) { 
                const worldBeforeZoom = inverseViewTransform(centerX, centerY); 
                zoomLevel = Math.max(0.1, Math.min(10, zoomLevel * factor));
                const worldAfterZoom = inverseViewTransform(centerX, centerY); 
                panX += (worldAfterZoom.x - worldBeforeZoom.x) * zoomLevel;
                panY += (worldAfterZoom.y - worldBeforeZoom.y) * zoomLevel;
                renderComposite();
            }
            function resetView() { zoomLevel = 1.0; panX = 0; panY = 0; renderComposite(); }

            function getDrawingStyle(ctx,p1x,p1y,p2x,p2y){ 
                if(currentColorMode==='solid'){return currentSolidColor;}
                else if(currentColorMode==='linear'){
                    const physX1 = p1x * deviceScale; const physY1 = p1y * deviceScale;
                    const physX2 = p2x * deviceScale; const physY2 = p2y * deviceScale;
                    if(physX1===physX2 && physY1===physY2){return currentGradient.start;} 
                    const grad=ctx.createLinearGradient(physX1,physY1,physX2,physY2);
                    grad.addColorStop(0,currentGradient.start);grad.addColorStop(1,currentGradient.end);return grad;
                }
                return currentSolidColor;
            }

            function startAction(event){ 
                const layerCtx=getActiveContext();if(!layerCtx){statusDiv.textContent="No active layer.";return;}
                if (isPanning && event.type && event.type.startsWith('mouse')) return; 

                const screenPos = getEventPos(event); 
                let {x: worldX, y: worldY} = inverseViewTransform(screenPos.x, screenPos.y); 
                
                if (currentTool !== 'select' && currentTool !== 'move') {
                    worldX = snapCoord(worldX, gridSize); worldY = snapCoord(worldY, gridSize);
                }
                
                saveHistory(); 
                [lastX,lastY]=[worldX,worldY];[startX,startY]=[worldX,worldY];

                if (currentTool === 'select') {
                    isSelecting = true;
                    deselect(); 
                    selectionRect = { x: worldX, y: worldY, width: 0, height: 0 };
                } else if (currentTool === 'move') {
                    if (selectionRect && 
                        worldX >= selectionRect.x && worldX <= selectionRect.x + selectionRect.width &&
                        worldY >= selectionRect.y && worldY <= selectionRect.y + selectionRect.height) {
                        
                        isMovingSelection = true;
                        isDrawing = true; // Use isDrawing for cursor update
                        const selPhysX = Math.round(selectionRect.x * deviceScale);
                        const selPhysY = Math.round(selectionRect.y * deviceScale);
                        const selPhysW = Math.round(selectionRect.width * deviceScale);
                        const selPhysH = Math.round(selectionRect.height * deviceScale);

                        if (selPhysW > 0 && selPhysH > 0) { // Ensure valid dimensions
                            movingSelectionData = {
                                imageData: layerCtx.getImageData(selPhysX, selPhysY, selPhysW, selPhysH),
                                x: selectionRect.x, 
                                y: selectionRect.y, 
                                offsetX: worldX - selectionRect.x, 
                                offsetY: worldY - selectionRect.y
                            };
                            layerCtx.save();
                            const clipPath = getSelectionClipPath(layerCtx, true);
                            layerCtx.clip(clipPath);
                            layerCtx.clearRect(0, 0, layerCtx.canvas.width, layerCtx.canvas.height);
                            layerCtx.restore();
                            statusDiv.textContent = "Moving selection...";
                        } else {
                            isMovingSelection = false; // Invalid selection to move
                            isDrawing = false;
                        }
                    } else {
                        isPanning = true; 
                        lastPanX_mouse = screenPos.x; lastPanY_mouse = screenPos.y;
                    }
                    updateCursor();
                } else { 
                    isDrawing=true;
                    const noSym=['fill','eyedropper'].includes(currentTool);
                    const sym=symmetryMode!=='OFF'&&!noSym;

                    if(currentTool==='pen'||currentTool==='eraser'){
                        setupLineDrawing(layerCtx,currentTool==='eraser',{x1:worldX,y1:worldY,x2:worldX,y2:worldY});
                        drawDot(layerCtx,worldX,worldY,sym);
                    }
                    else if(currentTool==='eyedropper'){
                        pickColor(screenPos.x,screenPos.y); 
                        isDrawing=false; 
                        if(previousTool&&previousTool!=='eyedropper')document.getElementById(previousTool+'Tool')?.click();
                        else document.getElementById('penTool').click();
                        return; 
                    }
                    else if(currentTool==='spray'){
                        setupLineDrawing(layerCtx,false,null);
                        sprayAt(layerCtx,worldX,worldY,sym);
                    }
                }
                renderComposite();
            }
            function performAction(event){ 
                if(!isDrawing && !isSelecting && !isPanning && !isMovingSelection) return;
                
                const screenPos = getEventPos(event);
                let {x: worldX,y: worldY} = inverseViewTransform(screenPos.x, screenPos.y);
                
                if (isPanning) { 
                    if (lastPanX_mouse === undefined) { lastPanX_mouse = screenPos.x; lastPanY_mouse = screenPos.y; }
                    const dx = screenPos.x - lastPanX_mouse; 
                    const dy = screenPos.y - lastPanY_mouse; 
                    panX += dx; panY += dy;
                    lastPanX_mouse = screenPos.x; lastPanY_mouse = screenPos.y;
                    renderComposite();
                    return;
                }

                const layerCtx = getActiveContext(); 
                if (!layerCtx && (isDrawing || isMovingSelection)) { endAction(event); return; }


                if (isSelecting && selectionRect) {
                    selectionRect.width = worldX - selectionRect.x;
                    selectionRect.height = worldY - selectionRect.y;
                } else if (isMovingSelection && movingSelectionData) {
                    movingSelectionData.x = worldX - movingSelectionData.offsetX;
                    movingSelectionData.y = worldY - movingSelectionData.offsetY;
                } else if (isDrawing && layerCtx) {
                    if (currentTool !== 'select' && currentTool !== 'move') {
                        worldX = snapCoord(worldX, gridSize); worldY = snapCoord(worldY, gridSize);
                    }
                    const noSym=['fill','eyedropper'].includes(currentTool);
                    const sym=symmetryMode!=='OFF'&&!noSym;
                    
                    if(currentTool==='pen'||currentTool==='eraser'){
                        setupLineDrawing(layerCtx,currentTool==='eraser',{x1:lastX,y1:lastY,x2:worldX,y2:worldY});
                        drawLine(layerCtx,lastX,lastY,worldX,worldY,sym);
                    }
                    else if(currentTool==='spray'){
                        setupLineDrawing(layerCtx,false,null);
                        sprayAt(layerCtx,worldX,worldY,sym);
                    }
                }
                
                [lastX,lastY]=[worldX,worldY];
                renderComposite();
            }
            function endAction(event){ 
                if (isPanning && event.type && event.type.startsWith('mouse')) { 
                    isPanning = false;
                    updateCursor();
                    if (!isDrawing && !isSelecting && !isMovingSelection) return; 
                }

                if (!isDrawing && !isSelecting && !isMovingSelection) return;

                const layerCtx=getActiveContext();
                
                let worldX = lastX, worldY = lastY;
                if (event && event.clientX !== undefined) { 
                     const screenPos = getEventPos(event);
                     const transformedPos = inverseViewTransform(screenPos.x, screenPos.y);
                     worldX = transformedPos.x;
                     worldY = transformedPos.y;
                }

                if (isSelecting && selectionRect) {
                    isSelecting = false;
                    if (selectionRect.width < 0) { selectionRect.x += selectionRect.width; selectionRect.width *= -1; }
                    if (selectionRect.height < 0) { selectionRect.y += selectionRect.height; selectionRect.height *= -1; }
                    if (selectionRect.width < 1 || selectionRect.height < 1) selectionRect = null; 
                    statusDiv.textContent = selectionRect ? "Selection made. Press Esc to clear." : "Selection too small.";
                } else if (isMovingSelection && movingSelectionData && layerCtx) {
                    isMovingSelection = false;
                    isDrawing = false; // Also reset isDrawing for move tool
                    if (movingSelectionData.imageData) { // Ensure imageData exists
                        layerCtx.putImageData(movingSelectionData.imageData, Math.round(movingSelectionData.x * deviceScale), Math.round(movingSelectionData.y * deviceScale));
                        saveHistory(); 
                    }
                    movingSelectionData = null;
                    statusDiv.textContent = "Selection moved.";
                    deselect(); 
                } else if (isDrawing && layerCtx) {
                    if (currentTool !== 'select' && currentTool !== 'move') { 
                        worldX = snapCoord(worldX, gridSize); worldY = snapCoord(worldY, gridSize);
                    }
                    const noSym=['fill','eyedropper'].includes(currentTool);
                    const sym=symmetryMode!=='OFF'&&!noSym;

                    if(currentTool === 'shape' || currentTool === 'line'){
                        drawShape(layerCtx,startX,startY,worldX,worldY,sym,{gradX1:startX,gradY1:startY,gradX2:worldX,gradY2:worldY});
                    }
                    else if(currentTool==='fill'){
                        statusDiv.textContent="Filling...";
                        setTimeout(()=>{
                            try{ floodFill(startX,startY); statusDiv.textContent="Fill complete.";}
                            catch(err){console.error("Fill Error:",err);statusDiv.textContent="Fill failed.";}
                            renderComposite(); saveHistory();
                        },10);
                        isDrawing = false; return; 
                    }
                    else if(currentTool==='text'){
                        addText(startX,startY,sym); 
                    } 
                    saveHistory(); 
                }
                
                isDrawing=false; 
                renderComposite();
                updateCursor();
            }
            
            function setupLineDrawing(ctx,isEraser,linePoints){ 
                ctx.lineWidth=currentWidth * deviceScale; 
                ctx.lineCap='round';ctx.lineJoin='round';
                if(currentStrokeStyle==='dashed')ctx.setLineDash([10*deviceScale,5*deviceScale]);
                else if(currentStrokeStyle==='dotted')ctx.setLineDash([Math.max(1,currentWidth*0.25)*deviceScale, currentWidth*1.5*deviceScale]);
                else ctx.setLineDash([]);
                
                if (selectionRect && currentTool !== 'select' && currentTool !== 'move' ) { 
                    ctx.save();
                    const clipPath = getSelectionClipPath(ctx, true);
                    ctx.clip(clipPath);
                }

                if(isEraser){ctx.globalCompositeOperation='destination-out';ctx.strokeStyle="rgba(0,0,0,1)";}
                else{ctx.globalCompositeOperation='source-over';
                    if(currentColorMode==='linear'&&linePoints && (linePoints.x1 !== linePoints.x2 || linePoints.y1 !== linePoints.y2) ){
                        ctx.strokeStyle=getDrawingStyle(ctx,linePoints.x1,linePoints.y1,linePoints.x2,linePoints.y2);
                    }else{ctx.strokeStyle=currentSolidColor;}
                }
            }
            function restoreContextAfterDraw(ctx) {
                if (selectionRect && currentTool !== 'select' && currentTool !== 'move' ) {
                    ctx.restore(); 
                }
            }

            function drawDot(ctx,worldX,worldY,applySymmetry){ 
                const _draw=(_ctx, _wx, _wy)=>{
                    const physX = _wx * deviceScale; 
                    const physY = _wy * deviceScale; 
                    const physWidth = currentWidth * deviceScale; 
                    _ctx.beginPath();
                    const style=(currentTool==='pen')?(currentColorMode==='solid'?currentSolidColor:getDrawingStyle(_ctx, _wx, _wy, _wx, _wy)): 'rgba(0,0,0,1)'; 
                    if (currentTool === 'pen' || currentTool === 'eraser') {
                         if (physWidth <= 1 * deviceScale) { 
                            _ctx.fillStyle = style;
                            _ctx.fillRect(Math.floor(physX - 0.5 * deviceScale), Math.floor(physY - 0.5 * deviceScale), Math.max(1, deviceScale), Math.max(1, deviceScale));
                        } else {
                            _ctx.arc(physX,physY,physWidth/2,0,Math.PI*2);
                            _ctx.fillStyle=style;
                            _ctx.fill();
                        }
                    }
                    _ctx.setLineDash([]); 
                };
                _draw(ctx,worldX,worldY);
                if(applySymmetry){
                    const {x: visCenterX_world, y: visCenterY_world} = inverseViewTransform(mainCanvas.clientWidth/2, mainCanvas.clientHeight/2);
                    if(symmetryMode==='Y')_draw(ctx, visCenterX_world * 2 - worldX ,worldY);
                    else if(symmetryMode==='X')_draw(ctx,worldX, visCenterY_world * 2 - worldY);
                    else if(symmetryMode==='XY'){_draw(ctx,visCenterX_world * 2 - worldX,worldY);_draw(ctx,worldX,visCenterY_world * 2 - worldY);_draw(ctx,visCenterX_world * 2 - worldX,visCenterY_world * 2 - worldY);}
                }
                restoreContextAfterDraw(ctx);
            }
            function drawLine(ctx,worldX1,worldY1,worldX2,worldY2,applySymmetry){ 
                const _draw=(_ctx, _wx1, _wy1, _wx2, _wy2)=>{
                    if(currentColorMode==='linear'&&currentTool!=='eraser'&& (_wx1 !== _wx2 || _wy1 !== _wy2)){
                        _ctx.strokeStyle=getDrawingStyle(_ctx,_wx1,_wy1,_wx2,_wy2);
                    } else if (currentTool!=='eraser' && currentColorMode==='solid') {
                         _ctx.strokeStyle = currentSolidColor;
                    } 
                    _ctx.beginPath();
                    _ctx.moveTo(_wx1 * deviceScale, _wy1 * deviceScale);
                    _ctx.lineTo(_wx2 * deviceScale, _wy2 * deviceScale);
                    _ctx.stroke();
                };
                _draw(ctx,worldX1,worldY1,worldX2,worldY2);
                if(applySymmetry){
                    const {x: visCenterX_world, y: visCenterY_world} = inverseViewTransform(mainCanvas.clientWidth/2, mainCanvas.clientHeight/2);
                    if(symmetryMode==='Y'){_draw(ctx,visCenterX_world*2-worldX1,worldY1,visCenterX_world*2-worldX2,worldY2);}
                    else if(symmetryMode==='X'){_draw(ctx,worldX1,visCenterY_world*2-worldY1,worldX2,visCenterY_world*2-worldY2);}
                    else if(symmetryMode==='XY'){_draw(ctx,visCenterX_world*2-worldX1,worldY1,visCenterX_world*2-worldX2,worldY2);_draw(ctx,worldX1,visCenterY_world*2-worldY1,worldX2,visCenterY_world*2-worldY2);_draw(ctx,visCenterX_world*2-worldX1,visCenterY_world*2-worldY1,visCenterX_world*2-worldX2,visCenterY_world*2-worldY2);}}
                restoreContextAfterDraw(ctx);
            }
            
            function drawShape(ctx,worldX1,worldY1,worldX2,worldY2,applySymmetry,gradPoints){ 
                 setupLineDrawing(ctx, false, gradPoints); 

                const _draw=(_ctx,_wx1,_wy1,_wx2,_wy2,_gradP)=>{ 
                    _ctx.lineWidth=currentWidth * deviceScale; 
                    _ctx.globalCompositeOperation='source-over';
                    const scaledDash = val => val * deviceScale;
                    if(currentStrokeStyle==='dashed')_ctx.setLineDash([scaledDash(10),scaledDash(5)]);
                    else if(currentStrokeStyle==='dotted')_ctx.setLineDash([scaledDash(Math.max(1,currentWidth*0.25)),scaledDash(currentWidth*1.5)]);
                    else _ctx.setLineDash([]);
                    
                    const sGradX1=_gradP.gradX1,sGradY1=_gradP.gradY1,sGradX2=_gradP.gradX2,sGradY2=_gradP.gradY2; 
                    const drawingStyle=getDrawingStyle(_ctx,sGradX1,sGradY1,sGradX2,sGradY2); 
                    
                    _ctx.strokeStyle=drawingStyle;
                    if(fillShapeCheckbox.checked) _ctx.fillStyle=drawingStyle;
                    
                    _ctx.beginPath(); 
                    let shapeToDraw=currentTool==='line'?'line':currentShapeType;
                    
                    const px1 = _wx1 * deviceScale, py1 = _wy1 * deviceScale; 
                    const px2 = _wx2 * deviceScale, py2 = _wy2 * deviceScale;

                    switch(shapeToDraw){
                        case 'line':_ctx.moveTo(px1,py1);_ctx.lineTo(px2,py2);_ctx.stroke();break;
                        case 'rectangle':const w=px2-px1,h=py2-py1;if(fillShapeCheckbox.checked)_ctx.fillRect(px1,py1,w,h);_ctx.strokeRect(px1,py1,w,h);break; 
                        case 'circle':const r=Math.sqrt(Math.pow(px2-px1,2)+Math.pow(py2-py1,2))/2,cx=px1+(px2-px1)/2,cy=py1+(py2-py1)/2;_ctx.arc(cx,cy,Math.abs(r),0,Math.PI*2);if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke();break; 
                        case 'ellipse': const el_cx = px1+(px2-px1)/2; const el_cy = py1+(py2-py1)/2; const el_rx = Math.abs(px2-px1)/2; const el_ry = Math.abs(py2-py1)/2; _ctx.ellipse(el_cx, el_cy, el_rx, el_ry, 0, 0, 2 * Math.PI); if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke(); break; 
                        case 'triangle': _ctx.moveTo((px1+px2)/2, py1); _ctx.lineTo(px2, py2); _ctx.lineTo(px1, py2); _ctx.closePath(); if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke(); break; 
                        case 'star': const spikes=5,outerR=Math.sqrt(Math.pow(px2-px1,2)+Math.pow(py2-py1,2))/2,innerR=outerR/2.5,rot=Math.PI/2*3;let starCX=px1+(px2-px1)/2,starCY=py1+(py2-py1)/2;_ctx.moveTo(starCX,starCY-outerR);for(let i=0;i<spikes;i++){_ctx.lineTo(starCX+Math.cos(rot+Math.PI/spikes*i*2)*outerR,starCY+Math.sin(rot+Math.PI/spikes*i*2)*outerR);_ctx.lineTo(starCX+Math.cos(rot+Math.PI/spikes*(i*2+1))*innerR,starCY+Math.sin(rot+Math.PI/spikes*(i*2+1))*innerR);}_ctx.closePath();if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke();break; 
                        case 'polygon': const sides=currentPolygonSides,polyR=Math.sqrt(Math.pow(px2-px1,2)+Math.pow(py2-py1,2))/2;const polyCX=px1+(px2-px1)/2,polyCY=py1+(py2-py1)/2;_ctx.moveTo(polyCX+polyR*Math.cos(0),polyCY+polyR*Math.sin(0));for(let i=1;i<=sides;i++)_ctx.lineTo(polyCX+polyR*Math.cos(i*2*Math.PI/sides),polyCY+polyR*Math.sin(i*2*Math.PI/sides));_ctx.closePath();if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke();break; 
                        case 'rhombus': _ctx.moveTo((px1+px2)/2, py1); _ctx.lineTo(px2, (py1+py2)/2); _ctx.lineTo((px1+px2)/2, py2); _ctx.lineTo(px1, (py1+py2)/2); _ctx.closePath(); if(fillShapeCheckbox.checked)_ctx.fill();_ctx.stroke(); break; 
                    }
                    _ctx.setLineDash([]);
                };
                _draw(ctx,worldX1,worldY1,worldX2,worldY2,gradPoints); 
                if(applySymmetry){ 
                    const {x: visCenterX_world, y: visCenterY_world} = inverseViewTransform(mainCanvas.clientWidth/2, mainCanvas.clientHeight/2);
                    if(symmetryMode==='Y')_draw(ctx,visCenterX_world*2-worldX1,worldY1,visCenterX_world*2-worldX2,worldY2,{gradX1:visCenterX_world*2-gradPoints.gradX1,gradY1:gradPoints.gradY1,gradX2:visCenterX_world*2-gradPoints.gradX2,gradY2:gradPoints.gradY2});
                    else if(symmetryMode==='X')_draw(ctx,worldX1,visCenterY_world*2-worldY1,worldX2,visCenterY_world*2-worldY2,{gradX1:gradPoints.gradX1,gradY1:visCenterY_world*2-gradPoints.gradY1,gradX2:gradPoints.gradX2,gradY2:visCenterY_world*2-gradPoints.gradY2});
                    else if(symmetryMode==='XY'){
                        _draw(ctx,visCenterX_world*2-worldX1,worldY1,visCenterX_world*2-worldX2,worldY2,{gradX1:visCenterX_world*2-gradPoints.gradX1,gradY1:gradPoints.gradY1,gradX2:visCenterX_world*2-gradPoints.gradX2,gradY2:gradPoints.gradY2});
                        _draw(ctx,worldX1,visCenterY_world*2-worldY1,worldX2,visCenterY_world*2-worldY2,{gradX1:gradPoints.gradX1,gradY1:visCenterY_world*2-gradPoints.gradY1,gradX2:gradPoints.gradX2,gradY2:visCenterY_world*2-gradPoints.gradY2});
                        _draw(ctx,visCenterX_world*2-worldX1,visCenterY_world*2-worldY1,visCenterX_world*2-worldX2,visCenterY_world*2-worldY2,{gradX1:visCenterX_world*2-gradPoints.gradX1,gradY1:visCenterY_world*2-gradPoints.gradY1,gradX2:visCenterX_world*2-gradPoints.gradX2,gradY2:visCenterY_world*2-gradPoints.gradY2});
                    }
                }
                 restoreContextAfterDraw(ctx);
            }

            function addText(worldX,worldY,applySymmetry){ 
                const ctx=getActiveContext();if(!ctx)return;
                const text=prompt("Enter text:","Hello!");
                if(text){
                    saveHistory();
                    setupLineDrawing(ctx, false, {x1:worldX, y1:worldY, x2:worldX + 10, y2:worldY}); 

                    const _draw=(_ctx,_x,_y,_align)=>{ 
                        _ctx.font=`${currentFontSize * deviceScale}px ${currentFontFamily}`; 
                        _ctx.textAlign=_align;_ctx.textBaseline="top";_ctx.globalCompositeOperation='source-over';
                        const metrics=_ctx.measureText(text); 
                        const textWidthPhysical = metrics.width;
                        const textWidthWorld = textWidthPhysical / deviceScale; 
                        let actualWorldX = _x; 
                        if(_align==='center') actualWorldX = _x; 
                        else if(_align==='right') actualWorldX = _x; 
                        let gradStartX = _x, gradEndX = _x + textWidthWorld;
                        if (_align === 'center') { gradStartX = _x - textWidthWorld / 2; gradEndX = _x + textWidthWorld / 2; } 
                        else if (_align === 'right') { gradStartX = _x - textWidthWorld; gradEndX = _x; }
                        _ctx.fillStyle=getDrawingStyle(_ctx,gradStartX,_y,gradEndX,_y); 
                        _ctx.fillText(text,_x * deviceScale,_y * deviceScale); 
                    };
                    _draw(ctx,worldX,worldY,currentTextAlign);
                    if(applySymmetry){
                        const {x: visCenterX_world, y: visCenterY_world} = inverseViewTransform(mainCanvas.clientWidth/2, mainCanvas.clientHeight/2);
                        let mirroredX;
                        if(symmetryMode==='Y'||symmetryMode==='XY'){mirroredX=visCenterX_world*2-worldX;_draw(ctx,mirroredX,worldY,currentTextAlign);}
                        if(symmetryMode==='X'||symmetryMode==='XY'){mirroredX=(symmetryMode==='XY')?visCenterX_world*2-worldX:worldX;_draw(ctx,mirroredX,visCenterY_world*2-worldY,currentTextAlign);}
                    }
                    restoreContextAfterDraw(ctx);
                    renderComposite();saveHistory();statusDiv.textContent=`Added text.`;
                }
            }
            function sprayAt(ctx,worldCX,worldCY,applySymmetry){ 
                setupLineDrawing(ctx, false, {x1:worldCX, y1:worldCY, x2:worldCX + 10, y2:worldCY}); 
                const _draw=(_ctx,_cx,_cy)=>{ 
                    const density=30+Math.floor(currentWidth/3);
                    const spreadWorld = currentWidth*1.5; 
                    _ctx.fillStyle=(currentColorMode==='solid')?currentSolidColor:getDrawingStyle(_ctx, _cx - spreadWorld/2, _cy, _cx + spreadWorld/2, _cy); 
                    _ctx.globalCompositeOperation='source-over';
                    for(let i=0;i<density;i++){
                        const a=Math.random()*2*Math.PI;
                        const rWorld=Math.random()*Math.random()*spreadWorld; 
                        const xWorld=_cx+rWorld*Math.cos(a);
                        const yWorld=_cy+rWorld*Math.sin(a);
                        _ctx.beginPath();
                        const particleRadiusPhysical = Math.max(1, (currentWidth*0.05)*deviceScale ); 
                        _ctx.arc(xWorld * deviceScale, yWorld * deviceScale, particleRadiusPhysical ,0,Math.PI*2);
                        _ctx.fill();
                    }
                };
                _draw(ctx,worldCX,worldCY);
                if(applySymmetry){
                    const {x: visCenterX_world, y: visCenterY_world} = inverseViewTransform(mainCanvas.clientWidth/2, mainCanvas.clientHeight/2);
                    if(symmetryMode==='Y')_draw(ctx,visCenterX_world*2-worldCX,worldCY);
                    else if(symmetryMode==='X')_draw(ctx,worldCX,visCenterY_world*2-worldCY);
                    else if(symmetryMode==='XY'){_draw(ctx,visCenterX_world*2-worldCX,worldCY);_draw(ctx,worldCX,visCenterY_world*2-worldCY);_draw(ctx,visCenterX_world*2-worldCX,visCenterY_world*2-worldCY);}}
                restoreContextAfterDraw(ctx);
            }
            function pickColor(screenX,screenY){ 
                const p=mainCtx.getImageData(Math.round(screenX * deviceScale), Math.round(screenY * deviceScale),1,1).data; 
                const c=`rgb(${p[0]},${p[1]},${p[2]})`;currentSolidColor=c;lineColorPicker.value=rgbToHex(p[0],p[1],p[2]);colorTypeSelect.value='solid';currentColorMode='solid';updateColorPropertiesUI();statusDiv.textContent=`Picked: ${c}. Solid mode.`;
            }
            function rgbToHex(r,g,b){return"#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();}
            
            function floodFill(worldStartX, worldStartY){ 
                const l=getActiveLayer();if(!l)return;const ctx=l.context; 
                
                const physicalStartX = Math.round(worldStartX * deviceScale); 
                const physicalStartY = Math.round(worldStartY * deviceScale);

                if(physicalStartX<0||physicalStartX>=ctx.canvas.width||physicalStartY<0||physicalStartY>=ctx.canvas.height){statusDiv.textContent="Fill start point outside canvas bounds.";return;}
                
                if (selectionRect) { 
                    const selPhysX = Math.round(selectionRect.x * deviceScale);
                    const selPhysY = Math.round(selectionRect.y * deviceScale);
                    const selPhysW = Math.round(selectionRect.width * deviceScale);
                    const selPhysH = Math.round(selectionRect.height * deviceScale);
                    if (physicalStartX < selPhysX || physicalStartX >= selPhysX + selPhysW ||
                        physicalStartY < selPhysY || physicalStartY >= selPhysY + selPhysH) {
                        statusDiv.textContent = "Fill start point outside selection.";
                        return;
                    }
                }
                
                const effFillClr=(currentColorMode==='solid')?currentSolidColor:currentGradient.start;
                const fillClrComponents=hexToRgbWithAlpha(effFillClr);if(!fillClrComponents)return;
                const[tR,tG,tB,tA]=fillClrComponents;
                
                const imageData=ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height); 
                const data=imageData.data; const canvasWidth=ctx.canvas.width; 

                const startPos=(physicalStartY*canvasWidth+physicalStartX)*4;
                const[startR,startG,startB,startA]=[data[startPos],data[startPos+1],data[startPos+2],data[startPos+3]];
                
                if(startR===tR&&startG===tG&&startB===tB&&startA===tA){statusDiv.textContent="Area already filled.";return;}
                
                const tolerance=20; 
                const colorMatch=(pos, x, y)=>{ 
                    if(pos<0||pos+3>=data.length)return false;
                    if (selectionRect) {
                        const selPhysX1 = Math.round(selectionRect.x * deviceScale);
                        const selPhysY1 = Math.round(selectionRect.y * deviceScale);
                        const selPhysX2 = selPhysX1 + Math.round(selectionRect.width * deviceScale);
                        const selPhysY2 = selPhysY1 + Math.round(selectionRect.height * deviceScale);
                        if (x < selPhysX1 || x >= selPhysX2 || y < selPhysY1 || y >= selPhysY2) return false;
                    }

                    const r=data[pos],g=data[pos+1],b=data[pos+2],a=data[pos+3];
                    if(r===tR&&g===tG&&b===tB&&a===tA)return false; 
                    return (Math.abs(r-startR) <= tolerance &&
                            Math.abs(g-startG) <= tolerance &&
                            Math.abs(b-startB) <= tolerance &&
                            Math.abs(a-startA) <= tolerance);
                };
                
                const q=[[physicalStartX,physicalStartY]];
                let iterations=0;const maxIterations=canvasWidth*ctx.canvas.height*2; 

                while(q.length>0&&iterations<maxIterations){
                    const[x_phys,y_phys]=q.pop();
                    if(x_phys<0||x_phys>=canvasWidth||y_phys<0||y_phys>=ctx.canvas.height)continue;
                    
                    const currentPos=(y_phys*canvasWidth+x_phys)*4;
                    if(!colorMatch(currentPos, x_phys, y_phys))continue; 
                
                    data[currentPos]=tR;data[currentPos+1]=tG;data[currentPos+2]=tB;data[currentPos+3]=tA;
                    iterations++;
                
                    q.push([x_phys-1,y_phys]);q.push([x_phys+1,y_phys]);
                    q.push([x_phys,y_phys-1]);q.push([x_phys,y_phys+1]);
                }
                if(iterations>=maxIterations)statusDiv.textContent="Fill might be incomplete.";
                ctx.putImageData(imageData,0,0);
            }
            function hexToRgbWithAlpha(hex){let c;if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){c=hex.substring(1).split('');if(c.length==3)c=[c[0],c[0],c[1],c[1],c[2],c[2]];c='0x'+c.join('');return[(c>>16)&255,(c>>8)&255,c&255,255];}const m=hex.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/);if(m)return[parseInt(m[1]),parseInt(m[2]),parseInt(m[3]),m[4]?Math.round(parseFloat(m[4])*255):255];return[0,0,0,255];}

            function applyEffectToLayer(effectFn) {
                const layerCtx = getActiveContext();
                if (!layerCtx) return;
                saveHistory();

                const processRegion = (x, y, w, h) => {
                    if (w <= 0 || h <= 0) return; 
                    const imageData = layerCtx.getImageData(x, y, w, h);
                    effectFn(imageData.data);
                    layerCtx.putImageData(imageData, x, y);
                };

                if (selectionRect && selectionRect.width > 0 && selectionRect.height > 0) {
                    const physX = Math.round(selectionRect.x * deviceScale);
                    const physY = Math.round(selectionRect.y * deviceScale);
                    const physW = Math.round(selectionRect.width * deviceScale);
                    const physH = Math.round(selectionRect.height * deviceScale);
                    processRegion(physX, physY, physW, physH);
                } else {
                    processRegion(0, 0, layerCtx.canvas.width, layerCtx.canvas.height);
                }
                saveHistory();
                renderComposite();
            }

            function applyGrayscaleEffect(){ applyEffectToLayer(data => { for(let i=0;i<data.length;i+=4){const avg=(data[i]+data[i+1]+data[i+2])/3;data[i]=data[i+1]=data[i+2]=avg;}}); statusDiv.textContent=`Grayscale on ${getActiveLayer().name}${selectionRect ? ' (selection)' : ''}.`;}
            function applyInvertEffect(){ applyEffectToLayer(data => { for(let i=0;i<data.length;i+=4){data[i]=255-data[i];data[i+1]=255-data[i+1];data[i+2]=255-data[i+2];}}); statusDiv.textContent=`Inverted ${getActiveLayer().name}${selectionRect ? ' (selection)' : ''}.`;}
            
            function flipLayer(horizontal, vertical) {
                const layerCtx = getActiveContext();
                if (!layerCtx) return;
                saveHistory();

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = layerCtx.canvas.width;
                tempCanvas.height = layerCtx.canvas.height;

                tempCtx.save();
                let scaleH = 1, scaleV = 1;
                let transX = 0, transY = 0;

                if (horizontal) {
                    scaleH = -1;
                    transX = -tempCanvas.width;
                }
                if (vertical) {
                    scaleV = -1;
                    transY = -tempCanvas.height;
                }
                tempCtx.scale(scaleH, scaleV);
                tempCtx.translate(transX, transY);
                tempCtx.drawImage(layerCtx.canvas, 0, 0);
                tempCtx.restore();

                layerCtx.clearRect(0, 0, layerCtx.canvas.width, layerCtx.canvas.height);
                layerCtx.drawImage(tempCanvas, 0, 0);

                saveHistory();
                renderComposite();
                statusDiv.textContent = `Layer ${getActiveLayer().name} flipped ${horizontal ? 'H' : ''}${vertical ? 'V' : ''}.`;
            }

            function addCurrentColorToPalette(){const cToAdd=(currentColorMode==='solid')?currentSolidColor:currentGradient.start;if(paletteColors.length>=MAX_PALETTE_COLORS){statusDiv.textContent="Palette full.";return;}if(!paletteColors.includes(cToAdd)){paletteColors.push(cToAdd);savePalette();renderPalette();statusDiv.textContent=`Added ${cToAdd}.`;}else{statusDiv.textContent=`${cToAdd} in palette.`;}}
            function renderPalette(){paletteContainer.innerHTML='';paletteColors.forEach(c=>{const s=document.createElement('div');s.className='swatch palette-swatch';s.style.backgroundColor=c;s.title=`Select ${c}`;s.onclick=()=>{currentSolidColor=c;lineColorPicker.value=c;colorTypeSelect.value='solid';currentColorMode='solid';updateColorPropertiesUI();statusDiv.textContent=`Selected ${c}.`;};paletteContainer.appendChild(s);});}
            function savePalette(){try{localStorage.setItem('sketcherPalette',JSON.stringify(paletteColors));}catch(e){console.warn("Could not save palette to localStorage:", e);}}
            function loadPalette(){try{const s=localStorage.getItem('sketcherPalette');if(s)paletteColors=JSON.parse(s);renderPalette();}catch(e){paletteColors=[]; console.warn("Could not load palette from localStorage:", e);}}
            function renderSolidColorTemplates(){solidTemplatesContainer.innerHTML='';solidColorTemplates.forEach(c=>{const s=document.createElement('div');s.className='swatch solid-template-swatch';s.style.backgroundColor=c;s.title=`Use ${c}`;s.onclick=()=>{currentSolidColor=c;lineColorPicker.value=c;colorTypeSelect.value='solid';currentColorMode='solid';updateColorPropertiesUI();statusDiv.textContent=`Template ${c} selected.`;};solidTemplatesContainer.appendChild(s);});}
            function renderGradientTemplates(){gradientTemplatesContainer.innerHTML='';gradientTemplates.forEach(t=>{const s=document.createElement('div');s.className='swatch gradient-template-swatch';s.style.background=`linear-gradient(to right, ${t.start}, ${t.end})`;s.title=`Use ${t.name} gradient`;s.onclick=()=>{currentGradient.start=t.start;currentGradient.end=t.end;gradientStartColorPicker.value=t.start;gradientEndColorPicker.value=t.end;colorTypeSelect.value='linear';currentColorMode='linear';updateColorPropertiesUI();statusDiv.textContent=`Template ${t.name} selected.`;};gradientTemplatesContainer.appendChild(s);});}

            function handleImageUpload(e){const ctx=getActiveContext();if(!ctx)return;const f=e.target.files[0];if(!f)return;statusDiv.textContent="Loading...";const r=new FileReader();r.onload=(ev)=>{const i=new Image();i.onload=()=>{saveHistory();const displayWidth = mainCanvas.width/deviceScale; const displayHeight = mainCanvas.height/deviceScale; const rt=Math.min(displayWidth/i.width,displayHeight/i.height,1); const drawW_world = i.width*rt; const drawH_world = i.height*rt; const worldX=(displayWidth-drawW_world)/2; const worldY=(displayHeight-drawH_world)/2; ctx.globalCompositeOperation='source-over';ctx.drawImage(i,0,0,i.width,i.height,worldX * deviceScale ,worldY * deviceScale,drawW_world* deviceScale,drawH_world* deviceScale); renderComposite();saveHistory();statusDiv.textContent="Image loaded.";};i.onerror=()=>{statusDiv.textContent="Image load error.";};i.src=ev.target.result;};r.onerror=()=>{statusDiv.textContent="File read error.";};r.readAsDataURL(f);e.target.value=null;}
            function clearCanvas(){if(confirm('Clear ALL layers?')){layers.forEach((l,i)=>{saveHistory(i);l.context.clearRect(0,0,l.canvas.width,l.canvas.height);saveHistory(i);});deselect();renderComposite();statusDiv.textContent="All cleared.";}}
            
            function saveCanvas(){
                const format=saveFormatSelect.value, mimeType=`image/${format}`; 
                const tempSaveCanvas = document.createElement('canvas'); 
                const displayWidth = mainCanvas.width / deviceScale;
                const displayHeight = mainCanvas.height / deviceScale;
                tempSaveCanvas.width = displayWidth; 
                tempSaveCanvas.height = displayHeight;
                const tempCtx = tempSaveCanvas.getContext('2d');
                
                const canvasBgColor = getComputedStyle(document.body).getPropertyValue('--canvas-bg').trim();
                tempCtx.fillStyle = canvasBgColor;
                tempCtx.fillRect(0,0,displayWidth,displayHeight);

                layers.forEach(layer => {
                    if(layer.visible && layer.canvas){
                        tempCtx.globalAlpha = layer.opacity;
                        tempCtx.globalCompositeOperation = layer.blendMode || 'source-over';
                        tempCtx.drawImage(layer.canvas, 0, 0, layer.canvas.width, layer.canvas.height, 0, 0, displayWidth, displayHeight);
                    }
                });
                tempCtx.globalAlpha = 1.0; 
                tempCtx.globalCompositeOperation = 'source-over'; 

                const dataURL=tempSaveCanvas.toDataURL(mimeType,format==='jpeg'?0.92:1.0); 
                const link=document.createElement('a');
                link.download=`SSSS_Lv_Sketcher.${format}`;
                link.href=dataURL;
                link.click();
                statusDiv.textContent=`Saved as ${format.toUpperCase()}.`;
            }

            function saveHistory(idx=activeLayerIndex){if(idx<0||idx>=layers.length)return;const l=layers[idx];if(!l||!l.canvas)return;try{const dU=l.canvas.toDataURL();const h=history[idx]||[];let s=historyStep[idx]===undefined?-1:historyStep[idx];if(s<h.length-1)history[idx]=h.slice(0,s+1);if(h.length===0||h[h.length-1]!==dU){if(h.length>=MAX_HISTORY_STEPS)h.shift();h.push(dU);historyStep[idx]=h.length-1;}updateUndoButtonState();}catch(err){console.warn(`History save fail ${l.name}: ${err.message}`);}}
            function undoLast(){if(activeLayerIndex<0||activeLayerIndex>=layers.length)return;const h=history[activeLayerIndex]||[];let s=historyStep[activeLayerIndex]===undefined?-1:historyStep[activeLayerIndex];if(s>0){try{s--;historyStep[activeLayerIndex]=s;const l=layers[activeLayerIndex],c=l.context,i=new Image();i.onload=()=>{c.clearRect(0,0,l.canvas.width,l.canvas.height);c.drawImage(i,0,0);renderComposite();statusDiv.textContent=`Undo on ${l.name}.`;};i.onerror=()=>{statusDiv.textContent="Undo fail.";};i.src=h[s];updateUndoButtonState();}catch(err){statusDiv.textContent="Undo fail.";}}else{statusDiv.textContent="No more undo.";}}
            function updateUndoButtonState(){if(activeLayerIndex<0||activeLayerIndex>=layers.length){undoBtn.disabled=true;return;}const s=historyStep[activeLayerIndex]===undefined?-1:historyStep[activeLayerIndex];undoBtn.disabled=s<=0; updateMergeButtonState();}
            
            function handleResize(){
                clearTimeout(handleResize.timeoutId);
                handleResize.timeoutId = setTimeout(() => {
                    console.log("Handling resize or orientation change.");
                    const oldDeviceScale = deviceScale;
                    deviceScale = window.devicePixelRatio || 1;
                    initializeCanvasAndLayers(); 
                    renderComposite();
                }, 150); 
            }
            handleResize.timeoutId = null;

            initializeApp();
        });
    </script>
</body>
</html>